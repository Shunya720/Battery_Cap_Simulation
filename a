"""
PVå‡ºåŠ›äºˆæ¸¬ã‚¦ã‚§ãƒ–ã‚¢ãƒ—ãƒª - Streamlitç‰ˆï¼ˆå®®å¤å³¶å…¨åœŸå¯¾å¿œç‰ˆ + Open-Meteo APIé€£æºä¿®æ­£ç‰ˆï¼‰
ä½¿ã„ã‚„ã™ã„Webã‚¤ãƒ³ã‚¿ãƒ¼ãƒ•ã‚§ãƒ¼ã‚¹ã§PVäºˆæ¸¬ã‚’å®Ÿè¡Œ

å®Ÿè¡Œæ–¹æ³•:
streamlit run pv_web_app.py
"""

import streamlit as st
import pandas as pd
import numpy as np
import plotly.graph_objects as go
import plotly.express as px
from datetime import datetime, timedelta
import os
import json
import traceback
import requests
from pathlib import Path

# ãƒšãƒ¼ã‚¸è¨­å®š
st.set_page_config(
    page_title="å®®å¤å³¶PVå‡ºåŠ›äºˆæ¸¬ã‚·ã‚¹ãƒ†ãƒ ",
    page_icon="ğŸï¸",
    layout="wide",
    initial_sidebar_state="expanded"
)

# CSSã‚¹ã‚¿ã‚¤ãƒ«
st.markdown("""
<style>
    .main-header {
        background: linear-gradient(90deg, #4A90E2, #50C878);
        padding: 1rem;
        border-radius: 10px;
        text-align: center;
        color: white;
        font-size: 2rem;
        font-weight: bold;
        margin-bottom: 2rem;
    }
    .metric-card {
        background: #f0f2f6;
        padding: 1rem;
        border-radius: 8px;
        border-left: 4px solid #1f77b4;
    }
    .success-box {
        background: #d4edda;
        border: 1px solid #c3e6cb;
        border-radius: 5px;
        padding: 1rem;
        margin: 1rem 0;
    }
    .error-box {
        background: #f8d7da;
        border: 1px solid #f5c6cb;
        border-radius: 5px;
        padding: 1rem;
        margin: 1rem 0;
    }
</style>
""", unsafe_allow_html=True)

def init_streamlit_session():
    """
    Streamlitã‚»ãƒƒã‚·ãƒ§ãƒ³ã®å®‰å…¨ãªåˆæœŸåŒ–ï¼ˆå®®å¤å³¶å¯¾å¿œç‰ˆï¼‰
    """
    # åŸºæœ¬è¨­å®šã®åˆæœŸåŒ–
    if 'prediction_date' not in st.session_state:
        st.session_state.prediction_date = datetime.now().date()

    if 'prediction_time' not in st.session_state:
        st.session_state.prediction_time = datetime.now().time()

    if 'num_points' not in st.session_state:
        st.session_state.num_points = 3

    # æ°—è±¡æ¡ä»¶ã®åˆæœŸåŒ–
    if 'current_irradiance' not in st.session_state:
        st.session_state.current_irradiance = 0.5

    if 'current_pv' not in st.session_state:
        st.session_state.current_pv = 40.0  # MW

    if 'weather_condition' not in st.session_state:
        st.session_state.weather_condition = "æ™´ã‚Œ"

    if 'cloud_cover' not in st.session_state:
        st.session_state.cloud_cover = 30

    if 'temperature' not in st.session_state:
        st.session_state.temperature = 25.0

    # å®®å¤å³¶PVã‚·ã‚¹ãƒ†ãƒ ä»•æ§˜ã®åˆæœŸåŒ–
    if 'pv_capacity' not in st.session_state:
        st.session_state.pv_capacity = 100.0  # MW

    # å®®å¤å³¶åœ°åŸŸç‰¹æ€§ã®åˆæœŸåŒ–
    if 'season_factor' not in st.session_state:
        st.session_state.season_factor = "æ˜¥å­£ï¼ˆ3-5æœˆï¼‰"

    if 'weather_risk' not in st.session_state:
        st.session_state.weather_risk = "å¹³å¸¸æ™‚"

    if 'operational_rate' not in st.session_state:
        st.session_state.operational_rate = 95.0

    if 'total_efficiency' not in st.session_state:
        st.session_state.total_efficiency = 0.16

    # Open-Meteo APIè¨­å®š
    if 'use_openmeteo' not in st.session_state:
        st.session_state.use_openmeteo = False

    if 'openmeteo_data' not in st.session_state:
        st.session_state.openmeteo_data = None

    if 'api_enabled' not in st.session_state:
        st.session_state.api_enabled = False

    # APIäºˆæ¸¬ãƒ‡ãƒ¼ã‚¿ä¿å­˜ç”¨
    if 'api_prediction_data' not in st.session_state:
        st.session_state.api_prediction_data = None

    # ãƒ¢ãƒ‡ãƒ«è¨­å®šã®åˆæœŸåŒ–
    if 'selected_model' not in st.session_state:
        st.session_state.selected_model = ""

    if 'model_type' not in st.session_state:
        st.session_state.model_type = "random_forest"

    if 'forecast_steps' not in st.session_state:
        st.session_state.forecast_steps = ["15åˆ†å…ˆ", "30åˆ†å…ˆ", "1æ™‚é–“å…ˆ"]

    # çµæœä¿å­˜ç”¨
    if 'last_prediction_results' not in st.session_state:
        st.session_state.last_prediction_results = None

    if 'model_loaded' not in st.session_state:
        st.session_state.model_loaded = False


class OpenMeteoWeatherAPI:
    """
    Open-Meteo APIé€£æºã‚¯ãƒ©ã‚¹ï¼ˆå®®å¤å³¶å¯¾å¿œå®Œå…¨ç‰ˆï¼‰
    """

    def __init__(self):
        # å®®å¤å³¶ã®åº§æ¨™
        self.latitude = 24.7902
        self.longitude = 125.3111
        self.base_url = "https://api.open-meteo.com/v1"

    @st.cache_data(ttl=1800)  # 30åˆ†ã‚­ãƒ£ãƒƒã‚·ãƒ¥
    def get_forecast_data(_self, past_days=1):
        """
        å®®å¤å³¶å‘ã‘forecastãƒ‡ãƒ¼ã‚¿ã‚’å–å¾—
        """
        try:
            url = f"{_self.base_url}/forecast"

            params = {
                'latitude': _self.latitude,
                'longitude': _self.longitude,
                'hourly': [
                    'temperature_2m',
                    'relative_humidity_2m',
                    'shortwave_radiation',
                    'direct_radiation',
                    'diffuse_radiation',
                    'cloud_cover',
                    'wind_speed_10m'
                ],
                'timezone': 'Asia/Tokyo',
                'past_days': past_days,
                'forecast_days': 1
            }

            response = requests.get(url, params=params, timeout=30)
            response.raise_for_status()

            data = response.json()

            # hourlyãƒ‡ãƒ¼ã‚¿ã®å‡¦ç†
            if 'hourly' in data and data['hourly']:
                df = pd.DataFrame({
                    'datetime': pd.to_datetime(data['hourly']['time']),
                    'temperature': data['hourly']['temperature_2m'],
                    'humidity': data['hourly'].get('relative_humidity_2m', [75.0] * len(data['hourly']['time'])),
                    'shortwave_radiation': data['hourly'].get('shortwave_radiation',
                                                              [500.0] * len(data['hourly']['time'])),
                    'direct_radiation': data['hourly'].get('direct_radiation', [400.0] * len(data['hourly']['time'])),
                    'diffuse_radiation': data['hourly'].get('diffuse_radiation', [100.0] * len(data['hourly']['time'])),
                    'cloud_cover': data['hourly'].get('cloud_cover', [30.0] * len(data['hourly']['time'])),
                    'wind_speed': data['hourly'].get('wind_speed_10m', [5.0] * len(data['hourly']['time']))
                })

                # æ—¥å°„å¼·åº¦ã‚’kW/mÂ²ã«å¤‰æ›
                df['æ—¥å°„å¼·åº¦'] = df['shortwave_radiation'] / 1000  # W/mÂ² â†’ kW/mÂ²
                df['ç›´é”æ—¥å°„'] = df['direct_radiation'] / 1000
                df['æ•£ä¹±æ—¥å°„'] = df['diffuse_radiation'] / 1000

                # PVå‡ºåŠ›ã‚’æ¨å®š
                pv_capacity = getattr(st.session_state, 'pv_capacity', 100.0)
                system_efficiency = 0.85
                df['PVå‡ºåŠ›'] = df['æ—¥å°„å¼·åº¦'] * pv_capacity * system_efficiency

                return df
            else:
                st.error("APIã‹ã‚‰æœ‰åŠ¹ãªãƒ‡ãƒ¼ã‚¿ã‚’å–å¾—ã§ãã¾ã›ã‚“ã§ã—ãŸ")
                return None

        except requests.exceptions.RequestException as e:
            st.error(f"APIæ¥ç¶šã‚¨ãƒ©ãƒ¼: {e}")
            return None
        except Exception as e:
            st.error(f"ãƒ‡ãƒ¼ã‚¿å‡¦ç†ã‚¨ãƒ©ãƒ¼: {e}")
            return None

    @st.cache_data(ttl=3600)  # 1æ™‚é–“ã‚­ãƒ£ãƒƒã‚·ãƒ¥
    def get_historical_weather(_self, start_date, end_date):
        """
        éå»ã®æ°—è±¡ãƒ‡ãƒ¼ã‚¿ã‚’å–å¾—ï¼ˆarchiveã‚¨ãƒ³ãƒ‰ãƒã‚¤ãƒ³ãƒˆä½¿ç”¨ï¼‰
        """
        try:
            url = f"{_self.base_url}/archive"

            params = {
                'latitude': _self.latitude,
                'longitude': _self.longitude,
                'start_date': start_date.strftime('%Y-%m-%d'),
                'end_date': end_date.strftime('%Y-%m-%d'),
                'hourly': [
                    'temperature_2m',
                    'relative_humidity_2m',
                    'shortwave_radiation',
                    'direct_radiation',
                    'diffuse_radiation',
                    'cloud_cover',
                    'wind_speed_10m'
                ],
                'timezone': 'Asia/Tokyo'
            }

            response = requests.get(url, params=params, timeout=30)
            response.raise_for_status()

            data = response.json()

            # ãƒ‡ãƒ¼ã‚¿ãƒ•ãƒ¬ãƒ¼ãƒ ä½œæˆ
            df = pd.DataFrame({
                'datetime': pd.to_datetime(data['hourly']['time']),
                'temperature': data['hourly']['temperature_2m'],
                'humidity': data['hourly']['relative_humidity_2m'],
                'shortwave_radiation': data['hourly']['shortwave_radiation'],
                'direct_radiation': data['hourly']['direct_radiation'],
                'diffuse_radiation': data['hourly']['diffuse_radiation'],
                'cloud_cover': data['hourly']['cloud_cover'],
                'wind_speed': data['hourly']['wind_speed_10m']
            })

            # æ—¥å°„å¼·åº¦ã‚’kW/mÂ²ã«å¤‰æ›
            df['æ—¥å°„å¼·åº¦'] = df['shortwave_radiation'] / 1000

            # PVå‡ºåŠ›ã‚’æ¨å®š
            pv_capacity = getattr(st.session_state, 'pv_capacity', 100.0)
            system_efficiency = 0.85
            df['PVå‡ºåŠ›'] = df['æ—¥å°„å¼·åº¦'] * pv_capacity * system_efficiency

            return df

        except requests.exceptions.RequestException as e:
            st.error(f"APIæ¥ç¶šã‚¨ãƒ©ãƒ¼: {e}")
            return None
        except Exception as e:
            st.error(f"ãƒ‡ãƒ¼ã‚¿å‡¦ç†ã‚¨ãƒ©ãƒ¼: {e}")
            return None

    @st.cache_data(ttl=900)  # 15åˆ†ã‚­ãƒ£ãƒƒã‚·ãƒ¥
    def get_today_hourly_data(_self):
        """
        æœ¬æ—¥ã®1æ™‚é–“é–“éš”ãƒ‡ãƒ¼ã‚¿ã‚’å–å¾—ï¼ˆ15åˆ†é–“éš”ã®ä»£æ›¿ï¼‰
        """
        try:
            url = f"{_self.base_url}/forecast"

            # ä»Šæ—¥ã®0æ™‚ã‹ã‚‰ç¾åœ¨ã¾ã§ã®æ™‚é–“ã‚’è¨ˆç®—
            now = datetime.now()
            today_start = datetime.combine(now.date(), datetime.min.time())

            # API ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿è¨­å®šï¼ˆhourlyã®ã¿ä½¿ç”¨ï¼‰
            params = {
                'latitude': _self.latitude,
                'longitude': _self.longitude,
                'hourly': [
                    'temperature_2m',
                    'relative_humidity_2m',
                    'shortwave_radiation',
                    'direct_radiation',
                    'diffuse_radiation',
                    'cloud_cover',
                    'wind_speed_10m'
                ],
                'timezone': 'Asia/Tokyo',
                'past_days': 1,
                'forecast_days': 0
            }

            response = requests.get(url, params=params, timeout=30)
            response.raise_for_status()

            data = response.json()

            # hourlyãƒ‡ãƒ¼ã‚¿ã®å‡¦ç†
            hourly_data = []
            if 'hourly' in data and data['hourly']:
                times = pd.to_datetime(data['hourly']['time'])
                temperature = data['hourly']['temperature_2m']
                humidity = data['hourly'].get('relative_humidity_2m', [75.0] * len(times))
                shortwave = data['hourly'].get('shortwave_radiation', [500.0] * len(times))
                direct = data['hourly'].get('direct_radiation', [400.0] * len(times))
                diffuse = data['hourly'].get('diffuse_radiation', [100.0] * len(times))
                cloud_cover = data['hourly'].get('cloud_cover', [30.0] * len(times))
                wind_speed = data['hourly'].get('wind_speed_10m', [5.0] * len(times))

                # ä»Šæ—¥ã®0æ™‚ä»¥é™ã®ãƒ‡ãƒ¼ã‚¿ã®ã¿ãƒ•ã‚£ãƒ«ã‚¿ãƒªãƒ³ã‚°
                for i, time in enumerate(times):
                    if today_start <= time <= now:
                        hourly_data.append({
                            'datetime': time,
                            'temperature': temperature[i] if i < len(temperature) and temperature[
                                i] is not None else 25.0,
                            'humidity': humidity[i] if i < len(humidity) and humidity[i] is not None else 75.0,
                            'shortwave_radiation': shortwave[i] if i < len(shortwave) and shortwave[
                                i] is not None else 500.0,
                            'direct_radiation': direct[i] if i < len(direct) and direct[i] is not None else 400.0,
                            'diffuse_radiation': diffuse[i] if i < len(diffuse) and diffuse[i] is not None else 100.0,
                            'cloud_cover': cloud_cover[i] if i < len(cloud_cover) and cloud_cover[
                                i] is not None else 30.0,
                            'wind_speed': wind_speed[i] if i < len(wind_speed) and wind_speed[i] is not None else 5.0
                        })

            if not hourly_data:
                st.warning("æœ¬æ—¥ã®1æ™‚é–“é–“éš”ãƒ‡ãƒ¼ã‚¿ãŒå–å¾—ã§ãã¾ã›ã‚“ã§ã—ãŸ")
                return None

            # ãƒ‡ãƒ¼ã‚¿ãƒ•ãƒ¬ãƒ¼ãƒ ä½œæˆ
            df = pd.DataFrame(hourly_data)

            # æ—¥å°„å¼·åº¦ã‚’kW/mÂ²ã«å¤‰æ›
            df['æ—¥å°„å¼·åº¦'] = df['shortwave_radiation'] / 1000  # W/mÂ² â†’ kW/mÂ²
            df['ç›´é”æ—¥å°„'] = df['direct_radiation'] / 1000
            df['æ•£ä¹±æ—¥å°„'] = df['diffuse_radiation'] / 1000

            # PVå‡ºåŠ›ã‚’æ¨å®š
            pv_capacity = getattr(st.session_state, 'pv_capacity', 100.0)
            system_efficiency = 0.85
            df['PVå‡ºåŠ›'] = df['æ—¥å°„å¼·åº¦'] * pv_capacity * system_efficiency

            # 15åˆ†é–“éš”ãƒ‡ãƒ¼ã‚¿ã‚’ã‚·ãƒŸãƒ¥ãƒ¬ãƒ¼ãƒˆï¼ˆè£œé–“ï¼‰
            df_interpolated = _self._interpolate_to_15min(df)

            # ãƒ‡ãƒ¼ã‚¿å–å¾—æƒ…å ±ã‚’ãƒ­ã‚°ã«å‡ºåŠ›
            st.info(f"âœ… æœ¬æ—¥0æ™‚ã€œç¾åœ¨: {len(df)}ä»¶ã®1æ™‚é–“é–“éš”ãƒ‡ãƒ¼ã‚¿ã‚’å–å¾—")
            st.info(f"ğŸ“Š 15åˆ†é–“éš”ã«è£œé–“: {len(df_interpolated)}ä»¶ã®ãƒ‡ãƒ¼ã‚¿")
            st.info(
                f"ğŸ“Š æ™‚é–“ç¯„å›²: {df_interpolated['datetime'].min().strftime('%H:%M')} ã€œ {df_interpolated['datetime'].max().strftime('%H:%M')}")

            return df_interpolated

        except requests.exceptions.RequestException as e:
            st.error(f"APIæ¥ç¶šã‚¨ãƒ©ãƒ¼: {e}")
            return None
        except Exception as e:
            st.error(f"æœ¬æ—¥1æ™‚é–“é–“éš”ãƒ‡ãƒ¼ã‚¿å‡¦ç†ã‚¨ãƒ©ãƒ¼: {e}")
            import traceback
            st.code(traceback.format_exc())
            return None

    def _interpolate_to_15min(self, hourly_df):
        """
        1æ™‚é–“é–“éš”ãƒ‡ãƒ¼ã‚¿ã‚’15åˆ†é–“éš”ã«ç·šå½¢è£œé–“
        """
        try:
            if len(hourly_df) < 2:
                return hourly_df

            # 15åˆ†é–“éš”ã®æ™‚é–“è»¸ã‚’ä½œæˆ
            start_time = hourly_df['datetime'].min()
            end_time = hourly_df['datetime'].max()

            # 15åˆ†é–“éš”ã®ã‚¿ã‚¤ãƒ ã‚¹ã‚¿ãƒ³ãƒ—ã‚’ç”Ÿæˆ
            time_range = pd.date_range(start=start_time, end=end_time, freq='15min')

            # æ–°ã—ã„ãƒ‡ãƒ¼ã‚¿ãƒ•ãƒ¬ãƒ¼ãƒ ã‚’ä½œæˆ
            interpolated_data = []

            for target_time in time_range:
                # æœ€ã‚‚è¿‘ã„å‰å¾Œã®æ™‚åˆ»ã‚’è¦‹ã¤ã‘ã‚‹
                before = hourly_df[hourly_df['datetime'] <= target_time]
                after = hourly_df[hourly_df['datetime'] >= target_time]

                if len(before) > 0 and len(after) > 0:
                    before_row = before.iloc[-1]
                    after_row = after.iloc[0]

                    if before_row['datetime'] == after_row['datetime']:
                        # å®Œå…¨ä¸€è‡´ã®å ´åˆ
                        interpolated_row = before_row.copy()
                        interpolated_row['datetime'] = target_time
                    else:
                        # ç·šå½¢è£œé–“
                        time_diff = (after_row['datetime'] - before_row['datetime']).total_seconds()
                        target_diff = (target_time - before_row['datetime']).total_seconds()
                        ratio = target_diff / time_diff if time_diff > 0 else 0

                        interpolated_row = {
                            'datetime': target_time,
                            'temperature': before_row['temperature'] + (
                                        after_row['temperature'] - before_row['temperature']) * ratio,
                            'humidity': before_row['humidity'] + (
                                        after_row['humidity'] - before_row['humidity']) * ratio,
                            'shortwave_radiation': before_row['shortwave_radiation'] + (
                                        after_row['shortwave_radiation'] - before_row['shortwave_radiation']) * ratio,
                            'direct_radiation': before_row['direct_radiation'] + (
                                        after_row['direct_radiation'] - before_row['direct_radiation']) * ratio,
                            'diffuse_radiation': before_row['diffuse_radiation'] + (
                                        after_row['diffuse_radiation'] - before_row['diffuse_radiation']) * ratio,
                            'cloud_cover': before_row['cloud_cover'] + (
                                        after_row['cloud_cover'] - before_row['cloud_cover']) * ratio,
                            'wind_speed': before_row['wind_speed'] + (
                                        after_row['wind_speed'] - before_row['wind_speed']) * ratio,
                            'æ—¥å°„å¼·åº¦': before_row['æ—¥å°„å¼·åº¦'] + (
                                        after_row['æ—¥å°„å¼·åº¦'] - before_row['æ—¥å°„å¼·åº¦']) * ratio,
                            'ç›´é”æ—¥å°„': before_row['ç›´é”æ—¥å°„'] + (
                                        after_row['ç›´é”æ—¥å°„'] - before_row['ç›´é”æ—¥å°„']) * ratio,
                            'æ•£ä¹±æ—¥å°„': before_row['æ•£ä¹±æ—¥å°„'] + (
                                        after_row['æ•£ä¹±æ—¥å°„'] - before_row['æ•£ä¹±æ—¥å°„']) * ratio,
                            'PVå‡ºåŠ›': before_row['PVå‡ºåŠ›'] + (after_row['PVå‡ºåŠ›'] - before_row['PVå‡ºåŠ›']) * ratio
                        }

                    interpolated_data.append(interpolated_row)
                elif len(before) > 0:
                    # å¾Œæ–¹å¤–æŒ¿
                    row = before.iloc[-1].copy()
                    row['datetime'] = target_time
                    interpolated_data.append(row)
                elif len(after) > 0:
                    # å‰æ–¹å¤–æŒ¿
                    row = after.iloc[0].copy()
                    row['datetime'] = target_time
                    interpolated_data.append(row)

            return pd.DataFrame(interpolated_data)

        except Exception as e:
            st.error(f"ãƒ‡ãƒ¼ã‚¿è£œé–“ã‚¨ãƒ©ãƒ¼: {e}")
            return hourly_df

    @st.cache_data(ttl=300)  # 5åˆ†ã‚­ãƒ£ãƒƒã‚·ãƒ¥
    def get_current_weather(_self):
        """
        ç¾åœ¨ã®æ°—è±¡ãƒ‡ãƒ¼ã‚¿ã‚’å–å¾—ï¼ˆæœ€æ–°ã®forecastãƒ‡ãƒ¼ã‚¿ã‚’ä½¿ç”¨ï¼‰
        """
        try:
            url = f"{_self.base_url}/forecast"

            params = {
                'latitude': _self.latitude,
                'longitude': _self.longitude,
                'current': [
                    'temperature_2m',
                    'relative_humidity_2m',
                    'cloud_cover'
                ],
                'hourly': [
                    'shortwave_radiation',
                    'wind_speed_10m'
                ],
                'timezone': 'Asia/Tokyo',
                'forecast_days': 1
            }

            response = requests.get(url, params=params, timeout=15)
            response.raise_for_status()

            data = response.json()

            # ç¾åœ¨ã®åŸºæœ¬ãƒ‡ãƒ¼ã‚¿
            current = data.get('current', {})

            # ç¾åœ¨æ™‚åˆ»ã«æœ€ã‚‚è¿‘ã„æ—¥å°„é‡ãƒ‡ãƒ¼ã‚¿ã‚’å–å¾—
            shortwave_radiation = 0
            wind_speed = 5.0

            if 'hourly' in data and data['hourly']:
                current_time = datetime.now()
                hourly_times = pd.to_datetime(data['hourly']['time'])

                # ç¾åœ¨æ™‚åˆ»ã«æœ€ã‚‚è¿‘ã„ãƒ‡ãƒ¼ã‚¿ã‚’è¦‹ã¤ã‘ã‚‹
                time_diffs = [abs((t - current_time).total_seconds()) for t in hourly_times]
                closest_index = time_diffs.index(min(time_diffs))

                if 'shortwave_radiation' in data['hourly'] and closest_index < len(
                        data['hourly']['shortwave_radiation']):
                    shortwave_radiation = data['hourly']['shortwave_radiation'][closest_index] or 0

                if 'wind_speed_10m' in data['hourly'] and closest_index < len(data['hourly']['wind_speed_10m']):
                    wind_speed = data['hourly']['wind_speed_10m'][closest_index] or 5.0

            # å¤œé–“ãƒã‚§ãƒƒã‚¯ï¼ˆå®®å¤å³¶ã®æ—¥ç…§æ™‚é–“: 6:00-18:30ï¼‰
            current_hour = datetime.now().hour + datetime.now().minute / 60.0
            if current_hour < 6.0 or current_hour > 18.5:
                shortwave_radiation = 0  # å¤œé–“ã¯æ—¥å°„é‡0

            return {
                'datetime': pd.to_datetime(current.get('time', datetime.now().isoformat())),
                'temperature': current.get('temperature_2m', 25.0),
                'humidity': current.get('relative_humidity_2m', 75.0),
                'cloud_cover': current.get('cloud_cover', 30.0),
                'wind_speed': wind_speed,
                'shortwave_radiation': shortwave_radiation,
                'irradiance': shortwave_radiation / 1000  # kW/mÂ²ã«å¤‰æ›
            }

        except Exception as e:
            st.warning(f"ç¾åœ¨æ°—è±¡ãƒ‡ãƒ¼ã‚¿å–å¾—ã‚¨ãƒ©ãƒ¼: {e}")
            # ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯ï¼šãƒ‡ãƒ•ã‚©ãƒ«ãƒˆå€¤ã‚’è¿”ã™
            current_hour = datetime.now().hour + datetime.now().minute / 60.0
            default_irradiance = 0.0 if (current_hour < 6.0 or current_hour > 18.5) else 0.5

            return {
                'datetime': pd.to_datetime(datetime.now()),
                'temperature': 25.0,
                'humidity': 75.0,
                'cloud_cover': 30.0,
                'wind_speed': 5.0,
                'shortwave_radiation': default_irradiance * 1000,
                'irradiance': default_irradiance
            }

    def test_api_connection(_self):
        """
        APIæ¥ç¶šãƒ†ã‚¹ãƒˆï¼ˆå®®å¤å³¶å¯¾å¿œç‰ˆï¼‰
        """
        try:
            url = f"{_self.base_url}/forecast"
            params = {
                'latitude': _self.latitude,
                'longitude': _self.longitude,
                'hourly': 'temperature_2m,shortwave_radiation',
                'current': 'temperature_2m',
                'timezone': 'Asia/Tokyo',
                'past_days': 1
            }

            response = requests.get(url, params=params, timeout=10)
            response.raise_for_status()

            data = response.json()

            # ãƒ‡ãƒ¼ã‚¿ã®å­˜åœ¨ç¢ºèª
            has_hourly = 'hourly' in data and data['hourly']
            has_current = 'current' in data and data['current']
            has_shortwave = has_hourly and 'shortwave_radiation' in data['hourly']

            return {
                'success': True,
                'status_code': response.status_code,
                'has_hourly': has_hourly,
                'has_current': has_current,
                'has_shortwave': has_shortwave,
                'has_minutely': False,  # å®®å¤å³¶ã§ã¯åˆ©ç”¨ä¸å¯
                'url': response.url,
                'note': 'å®®å¤å³¶ã§ã¯15åˆ†é–“éš”ãƒ‡ãƒ¼ã‚¿ã¯åˆ©ç”¨ã§ãã¾ã›ã‚“ã€‚1æ™‚é–“é–“éš”ãƒ‡ãƒ¼ã‚¿ã‚’è£œé–“ã—ã¦ä½¿ç”¨ã—ã¾ã™ã€‚'
            }

        except Exception as e:
            return {
                'success': False,
                'error': str(e),
                'url': f"{_self.base_url}/forecast",
                'note': 'APIæ¥ç¶šã«å¤±æ•—ã—ã¾ã—ãŸ'
            }


class StreamlitPVPredictor:
    """
    Streamlitç”¨PVäºˆæ¸¬ã‚¯ãƒ©ã‚¹ï¼ˆå®®å¤å³¶å¯¾å¿œç‰ˆãƒ»å®Ÿäºˆæ¸¬æ©Ÿã®ã¿ä½¿ç”¨ï¼‰
    """

    def __init__(self):
        self.predictor = None
        self.model_loaded = False
        self.model_info = {}
        # APIæ©Ÿèƒ½ã®åˆæœŸåŒ–
        self.weather_api = OpenMeteoWeatherAPI()

    @st.cache_resource
    def load_model(_self, model_path):
        """
        å­¦ç¿’æ¸ˆã¿ãƒ¢ãƒ‡ãƒ«ã®èª­ã¿è¾¼ã¿ï¼ˆå®Ÿäºˆæ¸¬æ©Ÿã®ã¿ä½¿ç”¨ï¼‰
        """
        try:
            # å®Ÿéš›ã®PVPredictorã‚¯ãƒ©ã‚¹ã®ã‚¤ãƒ³ãƒãƒ¼ãƒˆã‚’è©¦è¡Œ
            try:
                from prediction_example import PVPredictor
                predictor = PVPredictor(model_path)
                
                # ãƒ¢ãƒ‡ãƒ«ãŒæ­£å¸¸ã«èª­ã¿è¾¼ã¾ã‚ŒãŸã‹ç¢ºèª
                if predictor.predictor is None:
                    st.error("âŒ å¤–éƒ¨äºˆæ¸¬æ©Ÿã®èª­ã¿è¾¼ã¿ã«å¤±æ•—ã—ã¾ã—ãŸ")
                    st.error("ä»¥ä¸‹ã‚’ç¢ºèªã—ã¦ãã ã•ã„:")
                    st.error("1. prediction_example.pyãƒ•ã‚¡ã‚¤ãƒ«ãŒå­˜åœ¨ã™ã‚‹ã‹")
                    st.error("2. pv_prediction_models.pyãƒ•ã‚¡ã‚¤ãƒ«ãŒå­˜åœ¨ã™ã‚‹ã‹") 
                    st.error("3. å­¦ç¿’æ¸ˆã¿ãƒ¢ãƒ‡ãƒ«ãƒ•ã‚¡ã‚¤ãƒ«ãŒæ­£ã—ã„ãƒ‘ã‚¹ã«ä¿å­˜ã•ã‚Œã¦ã„ã‚‹ã‹")
                    return None, {}
                
            except ImportError as e:
                st.error("âŒ å¿…è¦ãªãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ãŒã‚¤ãƒ³ãƒãƒ¼ãƒˆã§ãã¾ã›ã‚“")
                st.error(f"ã‚¨ãƒ©ãƒ¼è©³ç´°: {e}")
                st.error("ä»¥ä¸‹ã®ãƒ•ã‚¡ã‚¤ãƒ«ãŒå¿…è¦ã§ã™:")
                st.error("- prediction_example.py")
                st.error("- pv_prediction_models.py")
                return None, {}

            # ãƒ¢ãƒ‡ãƒ«æƒ…å ±ã‚’èª­ã¿è¾¼ã¿
            metadata_file = os.path.join(model_path, "model_metadata.json")
            if os.path.exists(metadata_file):
                with open(metadata_file, 'r', encoding='utf-8') as f:
                    model_info = json.load(f)
            else:
                # ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã®ãƒ¢ãƒ‡ãƒ«æƒ…å ±
                model_info = {
                    'save_date': datetime.now().strftime('%Y-%m-%d %H:%M:%S'),
                    'data_info': {'total_samples': 'Unknown'},
                    'feature_columns': ['æ—¥å°„å¼·åº¦', 'PVå‡ºåŠ›', 'æ°—æ¸©', 'æ¹¿åº¦', 'é¢¨é€Ÿ'],
                    'location': 'å®®å¤å³¶',
                    'model_type': 'Real PV Predictor'
                }
            
            st.success("âœ… å¤–éƒ¨äºˆæ¸¬æ©Ÿã®èª­ã¿è¾¼ã¿ã«æˆåŠŸã—ã¾ã—ãŸ")
            return predictor, model_info

        except Exception as e:
            st.error(f"âŒ ãƒ¢ãƒ‡ãƒ«èª­ã¿è¾¼ã¿ã‚¨ãƒ©ãƒ¼: {e}")
            st.code(traceback.format_exc())
            return None, {}

    def calculate_pv_output(self, irradiance_values):
        """
        å®®å¤å³¶å…¨åœŸã®å¤ªé™½å…‰ç™ºé›»å‡ºåŠ›è¨ˆç®—ï¼ˆæ—¥ç…§æ™‚é–“è€ƒæ…®ç‰ˆï¼‰
        """
        try:
            # å…¥åŠ›å€¤ã®æ­£è¦åŒ–
            if isinstance(irradiance_values, (int, float)):
                irradiance_values = [irradiance_values]
            elif isinstance(irradiance_values, np.ndarray):
                irradiance_values = irradiance_values.tolist()

            # å®®å¤å³¶ã®åœ°åŸŸç‰¹æ€§
            miyako_location_factor = 0.95  # æ§˜ã€…ãªè¨­ç½®æ¡ä»¶ã®å¹³å‡

            # æ¸©åº¦è£œæ­£ï¼ˆå®®å¤å³¶ã®å¹´å¹³å‡æ°—æ¸©23.6Â°Cï¼‰
            temp_coeff = -0.004
            avg_temp = getattr(st.session_state, 'temperature', 23.6)
            cell_temp = avg_temp + 25
            temp_correction = 1 + temp_coeff * (cell_temp - 25)

            # å­£ç¯€ãƒ»æ°—è±¡è£œæ­£ã®å–å¾—
            season_correction = self.get_season_correction()
            weather_correction = self.get_weather_risk_correction()
            operational_correction = getattr(st.session_state, 'operational_rate', 95.0) / 100

            # å³¶å…¨ä½“ã®å¹³å‡
            avg_system_efficiency = 0.85

            # PVå‡ºåŠ›è¨ˆç®—
            pv_outputs = []
            for irradiance in irradiance_values:
                try:
                    irradiance_float = float(irradiance)

                    # æ—¥å°„å¼·åº¦ãŒæ¥µã‚ã¦ä½ã„å ´åˆï¼ˆå¤œé–“ï¼‰ã¯å‡ºåŠ›ã‚’0ã«ã™ã‚‹
                    if irradiance_float < 0.01:  # 0.01 kW/mÂ²æœªæº€ã¯å¤œé–“ã¨ã¿ãªã™
                        pv_outputs.append(0.0)
                        continue

                    # å®®å¤å³¶å…¨åœŸã®ç™ºé›»é‡è¨ˆç®—ï¼ˆMWï¼‰
                    output = (
                            irradiance_float *
                            st.session_state.pv_capacity *
                            avg_system_efficiency *
                            miyako_location_factor *
                            temp_correction *
                            season_correction *
                            weather_correction *
                            operational_correction
                    )

                    # åˆ¶é™
                    output = max(0, min(output, st.session_state.pv_capacity))
                    pv_outputs.append(output)

                except (ValueError, TypeError):
                    pv_outputs.append(0.0)

            return np.array(pv_outputs)

        except Exception as e:
            st.error(f"PVå‡ºåŠ›è¨ˆç®—ã‚¨ãƒ©ãƒ¼: {e}")
            return np.array([0.0] * len(irradiance_values) if isinstance(irradiance_values, list) else [0.0])

    def get_season_correction(self):
        """å­£ç¯€è£œæ­£ä¿‚æ•°ã®å–å¾—"""
        seasonal_factors = {
            "æ˜¥å­£ï¼ˆ3-5æœˆï¼‰": 1.0,
            "å¤å­£ï¼ˆ6-8æœˆï¼‰": 0.92,
            "ç§‹å­£ï¼ˆ9-11æœˆï¼‰": 1.05,
            "å†¬å­£ï¼ˆ12-2æœˆï¼‰": 0.98
        }
        return seasonal_factors.get(getattr(st.session_state, 'season_factor', 'æ˜¥å­£ï¼ˆ3-5æœˆï¼‰'), 1.0)

    def get_weather_risk_correction(self):
        """æ°—è±¡ãƒªã‚¹ã‚¯è£œæ­£ä¿‚æ•°ã®å–å¾—"""
        weather_factors = {
            "å¹³å¸¸æ™‚": 1.0,
            "å°é¢¨æ¥è¿‘": 0.3,
            "æ¢…é›¨æœŸ": 0.6,
            "é«˜æ¸©æœŸ": 0.88
        }
        return weather_factors.get(getattr(st.session_state, 'weather_risk', 'å¹³å¸¸æ™‚'), 1.0)

    def create_pv_system_form(self):
        """
        å®®å¤å³¶å…¨åœŸPVã‚·ã‚¹ãƒ†ãƒ ä»•æ§˜å…¥åŠ›ãƒ•ã‚©ãƒ¼ãƒ 
        """
        st.subheader("ğŸï¸ å®®å¤å³¶å…¨åœŸPVã‚·ã‚¹ãƒ†ãƒ è¨­å®š")

        col1, col2 = st.columns(2)

        with col1:
            st.write("**åŸºæœ¬ä»•æ§˜**")

            st.session_state.pv_capacity = st.number_input(
                "ç·PVå®¹é‡ (MW)",
                min_value=1.0,
                max_value=1000.0,
                value=float(st.session_state.pv_capacity),
                step=1.0,
                help="å®®å¤å³¶å…¨åœŸã®å¤ªé™½å…‰ç™ºé›»ã‚·ã‚¹ãƒ†ãƒ ã®ç·å®¹é‡"
            )

            # å®®å¤å³¶åœ°åŸŸç‰¹æ€§ï¼ˆå›ºå®šå€¤ï¼‰
            st.info("ğŸ“ **å®®å¤å³¶åœ°åŸŸç‰¹æ€§ï¼ˆå›ºå®šå€¤ï¼‰**")
            st.write(f"- ç·¯åº¦: 24.8Â°Nï¼ˆæœ€é©å‚¾æ–œè§’: 25Â°ï¼‰")
            st.write(f"- å¹´é–“æ—¥å°„é‡: 1,600 kWh/mÂ²")
            st.write(f"- å¹³å‡æ°—æ¸©: 23.6Â°C")
            st.write(f"- ç‰¹å¾´: äºœç†±å¸¯æµ·æ´‹æ€§æ°—å€™")

        with col2:
            st.write("**åœ°åŸŸæ°—è±¡æ¡ä»¶**")

            # å­£ç¯€è¦å› 
            st.session_state.season_factor = st.selectbox(
                "å­£ç¯€è¦å› ",
                ["æ˜¥å­£ï¼ˆ3-5æœˆï¼‰", "å¤å­£ï¼ˆ6-8æœˆï¼‰", "ç§‹å­£ï¼ˆ9-11æœˆï¼‰", "å†¬å­£ï¼ˆ12-2æœˆï¼‰"],
                index=["æ˜¥å­£ï¼ˆ3-5æœˆï¼‰", "å¤å­£ï¼ˆ6-8æœˆï¼‰", "ç§‹å­£ï¼ˆ9-11æœˆï¼‰", "å†¬å­£ï¼ˆ12-2æœˆï¼‰"].index(
                    st.session_state.season_factor
                ),
                help="å®®å¤å³¶ã®å­£ç¯€ã«ã‚ˆã‚‹ç™ºé›»åŠ¹ç‡ã®å¤‰å‹•"
            )

            # å°é¢¨ãƒ»æ°—è±¡ãƒªã‚¹ã‚¯
            st.session_state.weather_risk = st.selectbox(
                "æ°—è±¡ãƒªã‚¹ã‚¯",
                ["å¹³å¸¸æ™‚", "å°é¢¨æ¥è¿‘", "æ¢…é›¨æœŸ", "é«˜æ¸©æœŸ"],
                index=["å¹³å¸¸æ™‚", "å°é¢¨æ¥è¿‘", "æ¢…é›¨æœŸ", "é«˜æ¸©æœŸ"].index(
                    st.session_state.weather_risk
                ),
                help="ç‰¹æ®Šæ°—è±¡æ¡ä»¶ã«ã‚ˆã‚‹ç™ºé›»ã¸ã®å½±éŸ¿"
            )

            # å³¶å…¨ä½“ã®ç¨¼åƒç‡
            st.session_state.operational_rate = st.slider(
                "ã‚·ã‚¹ãƒ†ãƒ ç¨¼åƒç‡ (%)",
                min_value=80.0,
                max_value=100.0,
                value=float(st.session_state.operational_rate),
                step=1.0,
                help="ãƒ¡ãƒ³ãƒ†ãƒŠãƒ³ã‚¹ãƒ»æ•…éšœç­‰ã‚’è€ƒæ…®ã—ãŸå…¨ä½“ç¨¼åƒç‡"
            )

            # ç·åˆåŠ¹ç‡ã®è¨ˆç®—ã¨è¡¨ç¤º
            season_correction = self.get_season_correction()
            weather_correction = self.get_weather_risk_correction()

            total_efficiency = (
                    season_correction *
                    weather_correction *
                    st.session_state.operational_rate / 100
            )

            st.session_state.total_efficiency = total_efficiency

            st.write("**ç·åˆç™ºé›»åŠ¹ç‡**")
            if total_efficiency > 0.15:
                st.success(f"ğŸŒŸ é«˜åŠ¹ç‡: {total_efficiency:.1%}")
            elif total_efficiency > 0.12:
                st.info(f"âœ… æ¨™æº–åŠ¹ç‡: {total_efficiency:.1%}")
            else:
                st.warning(f"âš ï¸ ä½åŠ¹ç‡: {total_efficiency:.1%}")

        return True

    def create_input_data_form(self):
        """
        å®®å¤å³¶å‘ã‘å…¥åŠ›ãƒ‡ãƒ¼ã‚¿ãƒ•ã‚©ãƒ¼ãƒ ã®ä½œæˆï¼ˆOpen-Meteo APIå¯¾å¿œä¿®æ­£ç‰ˆï¼‰
        """
        st.subheader("ğŸ“Š äºˆæ¸¬ç”¨ãƒ‡ãƒ¼ã‚¿å…¥åŠ›")

        # PVã‚·ã‚¹ãƒ†ãƒ ä»•æ§˜å…¥åŠ›
        self.create_pv_system_form()

        # ã‚¿ãƒ–ã§å…¥åŠ›æ–¹æ³•ã‚’é¸æŠ
        tab1, tab2, tab3 = st.tabs(["æ‰‹å‹•å…¥åŠ›", "Open-Meteo API", "CSVãƒ•ã‚¡ã‚¤ãƒ«ã‚¢ãƒƒãƒ—ãƒ­ãƒ¼ãƒ‰"])

        input_data = None

        with tab1:
            input_data = self._manual_input_form()

        with tab2:
            # APIãƒ‡ãƒ¼ã‚¿ãŒæº–å‚™ã•ã‚Œã¦ã„ã‚‹ã‹ãƒã‚§ãƒƒã‚¯
            if 'api_prediction_data' in st.session_state and st.session_state.api_prediction_data is not None:
                st.success("ğŸ‰ äºˆæ¸¬ãƒ‡ãƒ¼ã‚¿ãŒæº–å‚™ã•ã‚Œã¦ã„ã¾ã™ï¼")
                st.info("â¬‡ï¸ ä¸‹è¨˜ã§äºˆæ¸¬çµæœã‚’ç¢ºèªã—ã¦ãã ã•ã„")
                input_data = st.session_state.api_prediction_data
            else:
                # APIãƒ•ã‚©ãƒ¼ãƒ ã‚’è¡¨ç¤º
                temp_data = self._openmeteo_input_form()
                if temp_data is not None:
                    input_data = temp_data

        with tab3:
            input_data = self._csv_input_form()

        return input_data

    def _manual_input_form(self):
        """æ‰‹å‹•å…¥åŠ›ãƒ•ã‚©ãƒ¼ãƒ """
        col1, col2 = st.columns(2)

        with col1:
            st.write("**åŸºæœ¬æƒ…å ±**")

            st.session_state.prediction_date = st.date_input(
                "äºˆæ¸¬åŸºæº–æ—¥",
                value=st.session_state.prediction_date
            )

            st.session_state.prediction_time = st.time_input(
                "äºˆæ¸¬åŸºæº–æ™‚åˆ»",
                value=st.session_state.prediction_time
            )

            st.session_state.num_points = st.slider(
                "äºˆæ¸¬ãƒ‡ãƒ¼ã‚¿ç‚¹æ•°",
                1, 10,
                value=int(st.session_state.num_points)
            )

            st.write("**ç¾åœ¨ã®æ°—è±¡æ¡ä»¶**")

            st.session_state.current_irradiance = st.number_input(
                "ç¾åœ¨ã®æ—¥å°„å¼·åº¦ (kW/mÂ²)",
                min_value=0.0,
                max_value=1.2,
                value=float(st.session_state.current_irradiance),
                step=0.01,
                help="0.0ï¼ˆå¤œé–“ï¼‰ã€œ 1.0ï¼ˆå¿«æ™´æ™‚ï¼‰"
            )

            # ç¾åœ¨ã®PVå‡ºåŠ›ã‚’è¨ˆç®—ã—ã¦è¡¨ç¤º
            current_pv_calc = self.calculate_pv_output([st.session_state.current_irradiance])[0]
            st.info(f"ğŸ’¡ è¨ˆç®—PVå‡ºåŠ›: {current_pv_calc:.1f} MW")

            # PVå‡ºåŠ›ã‚’æ—¥å°„å¼·åº¦ã¨é€£å‹•ã•ã›ã‚‹ã‹ã®ã‚ªãƒ—ã‚·ãƒ§ãƒ³
            auto_pv = st.checkbox("PVå‡ºåŠ›ã‚’è‡ªå‹•è¨ˆç®—", value=True)

            if auto_pv:
                st.session_state.current_pv = current_pv_calc
                st.write(f"ç¾åœ¨ã®PVå‡ºåŠ›: {st.session_state.current_pv:.1f} MW (è‡ªå‹•è¨ˆç®—)")
            else:
                st.session_state.current_pv = st.number_input(
                    "ç¾åœ¨ã®PVå‡ºåŠ› (MW)",
                    min_value=0.0,
                    max_value=float(st.session_state.pv_capacity),
                    value=float(min(st.session_state.current_pv, st.session_state.pv_capacity)),
                    step=1.0
                )

        with col2:
            st.write("**å¤©å€™æ¡ä»¶**")

            st.session_state.weather_condition = st.selectbox(
                "å¤©å€™",
                ["æ™´ã‚Œ", "æ›‡ã‚Š", "é›¨", "ãã®ä»–"],
                index=["æ™´ã‚Œ", "æ›‡ã‚Š", "é›¨", "ãã®ä»–"].index(st.session_state.weather_condition)
            )

            st.session_state.cloud_cover = st.slider(
                "é›²é‡ï¼ˆ%ï¼‰",
                0, 100,
                value=int(st.session_state.cloud_cover)
            )

            st.session_state.temperature = st.number_input(
                "æ°—æ¸©ï¼ˆâ„ƒï¼‰",
                min_value=10.0,
                max_value=40.0,
                value=float(st.session_state.temperature),
                step=0.5,
                help="å®®å¤å³¶ã®æ°—æ¸©ç¯„å›²: 10-40Â°C"
            )

            # ç™ºé›»åŠ¹ç‡ã®è¡¨ç¤º
            temp_coeff = -0.004
            cell_temp = st.session_state.temperature + 25
            temp_correction = 1 + temp_coeff * (cell_temp - 25)
            season_correction = self.get_season_correction()
            weather_correction = self.get_weather_risk_correction()

            total_efficiency = temp_correction * season_correction * weather_correction

            st.write("**ç¾åœ¨ã®ç™ºé›»åŠ¹ç‡**")
            if total_efficiency > 1.0:
                st.success(f"ğŸŒŸ é«˜åŠ¹ç‡: {total_efficiency:.1%}")
            elif total_efficiency < 0.7:
                st.error(f"âš ï¸ ä½åŠ¹ç‡: {total_efficiency:.1%}")
            else:
                st.info(f"âœ… æ¨™æº–åŠ¹ç‡: {total_efficiency:.1%}")

        # äºˆæ¸¬å®Ÿè¡Œãƒœã‚¿ãƒ³
        col_btn1, col_btn2, col_btn3 = st.columns([1, 1, 1])

        with col_btn1:
            if st.button("ğŸ”„ è¨­å®šã‚’ãƒªã‚»ãƒƒãƒˆ"):
                self.reset_input_values()
                st.rerun()

        with col_btn2:
            if st.button("ğŸ’¾ è¨­å®šã‚’ä¿å­˜"):
                self.save_current_settings()
                st.success("è¨­å®šã‚’ä¿å­˜ã—ã¾ã—ãŸï¼")

        with col_btn3:
            if st.button("ğŸ“ˆ æ‰‹å‹•ãƒ‡ãƒ¼ã‚¿ã§äºˆæ¸¬å®Ÿè¡Œ", type="primary"):
                # æ‰‹å‹•å…¥åŠ›ãƒ‡ãƒ¼ã‚¿ã‹ã‚‰äºˆæ¸¬ç”¨ãƒ‡ãƒ¼ã‚¿ãƒ•ãƒ¬ãƒ¼ãƒ ã‚’ä½œæˆ
                input_data = self.create_prediction_data_from_input()
                return input_data

        return None

    def _openmeteo_input_form(self):
        """Open-Meteo APIå…¥åŠ›ãƒ•ã‚©ãƒ¼ãƒ ï¼ˆä¿®æ­£ç‰ˆï¼‰"""
        try:
            st.write("**ğŸŒ Open-Meteo APIã‹ã‚‰å®Ÿéš›ã®æ°—è±¡ãƒ‡ãƒ¼ã‚¿ã‚’å–å¾—**")

            # APIæ©Ÿèƒ½ãŒç„¡åŠ¹ã®å ´åˆã®è­¦å‘Š
            if not st.session_state.api_enabled:
                st.warning(
                    "âš ï¸ Open-Meteo APIæ©Ÿèƒ½ãŒç„¡åŠ¹ã§ã™ã€‚ã‚µã‚¤ãƒ‰ãƒãƒ¼ã§ã€ŒOpen-Meteo APIä½¿ç”¨ã€ã«ãƒã‚§ãƒƒã‚¯ã‚’å…¥ã‚Œã¦ãã ã•ã„ã€‚")
                return None

            # APIæ¥ç¶šçŠ¶æ³ã®è¡¨ç¤º
            st.info("ğŸ“ **å¯¾è±¡åœ°åŸŸ:** å®®å¤å³¶ (åŒ—ç·¯24.8Â°, æ±çµŒ125.3Â°)")

            col1, col2 = st.columns(2)

            with col1:
                st.write("**ãƒ‡ãƒ¼ã‚¿å–å¾—è¨­å®š**")

                # æœŸé–“é¸æŠ
                data_type = st.selectbox(
                    "ãƒ‡ãƒ¼ã‚¿ã‚¿ã‚¤ãƒ—",
                    ["1æ™‚é–“é–“éš”æ—¥å°„å¼·åº¦å–å¾—", "ç¾åœ¨+ç›´è¿‘24æ™‚é–“", "éå»1é€±é–“", "éå»1ãƒ¶æœˆ", "ã‚«ã‚¹ã‚¿ãƒ æœŸé–“"],
                    help="å–å¾—ã™ã‚‹æ°—è±¡ãƒ‡ãƒ¼ã‚¿ã®æœŸé–“ã‚’é¸æŠ",
                    key="api_data_type_openmeteo"
                )

                if data_type == "ã‚«ã‚¹ã‚¿ãƒ æœŸé–“":
                    start_date = st.date_input(
                        "é–‹å§‹æ—¥",
                        value=datetime.now().date() - timedelta(days=7),
                        max_value=datetime.now().date(),
                        key="api_start_date_openmeteo"
                    )
                    end_date = st.date_input(
                        "çµ‚äº†æ—¥",
                        value=datetime.now().date(),
                        max_value=datetime.now().date(),
                        key="api_end_date_openmeteo"
                    )
                else:
                    end_date = datetime.now().date()
                    if data_type == "ç¾åœ¨+ç›´è¿‘24æ™‚é–“":
                        start_date = end_date - timedelta(days=1)
                    elif data_type == "éå»1é€±é–“":
                        start_date = end_date - timedelta(days=7)
                    elif data_type == "1æ™‚é–“é–“éš”æ—¥å°„å¼·åº¦å–å¾—":
                        start_date = end_date
                    else:  # éå»1ãƒ¶æœˆ
                        start_date = end_date - timedelta(days=30)

                st.info(f"ğŸ“… æœŸé–“: {start_date} ã€œ {end_date}")

                # ãƒ‡ãƒ¼ã‚¿å–å¾—ãƒœã‚¿ãƒ³
                if st.button("ğŸŒ¤ï¸ æ°—è±¡ãƒ‡ãƒ¼ã‚¿ã‚’å–å¾—", type="primary", key="fetch_weather_btn_openmeteo"):
                    with st.spinner("ğŸŒ Open-Meteo APIã‹ã‚‰ãƒ‡ãƒ¼ã‚¿å–å¾—ä¸­..."):
                        try:
                            # APIåˆæœŸåŒ–ã®ç¢ºèª
                            if not hasattr(self, 'weather_api') or self.weather_api is None:
                                self.weather_api = OpenMeteoWeatherAPI()

                            # ãƒ‡ãƒ¼ã‚¿ã‚¿ã‚¤ãƒ—ã«å¿œã˜ã¦ãƒ‡ãƒ¼ã‚¿å–å¾—
                            if data_type == "1æ™‚é–“é–“éš”æ—¥å°„å¼·åº¦å–å¾—":
                                # æœ¬æ—¥ã®1æ™‚é–“é–“éš”ãƒ‡ãƒ¼ã‚¿ã‚’å–å¾—
                                weather_data = self.weather_api.get_today_hourly_data()
                                data_source = "1æ™‚é–“é–“éš”æ—¥å°„å¼·åº¦ãƒ‡ãƒ¼ã‚¿ (æœ¬æ—¥ã€15åˆ†è£œé–“æ¸ˆã¿)"
                            elif data_type == "ç¾åœ¨+ç›´è¿‘24æ™‚é–“":
                                # forecast ã‚¨ãƒ³ãƒ‰ãƒã‚¤ãƒ³ãƒˆã‚’ä½¿ç”¨
                                weather_data = self.weather_api.get_forecast_data(past_days=1)
                                data_source = "Forecast API (1æ™‚é–“é–“éš”)"
                            else:
                                # archive ã‚¨ãƒ³ãƒ‰ãƒã‚¤ãƒ³ãƒˆã‚’ä½¿ç”¨
                                weather_data = self.weather_api.get_historical_weather(
                                    datetime.combine(start_date, datetime.min.time()),
                                    datetime.combine(end_date, datetime.max.time())
                                )
                                data_source = "Archive API (1æ™‚é–“é–“éš”)"

                            if weather_data is not None and len(weather_data) > 0:
                                st.session_state.openmeteo_data = weather_data
                                st.session_state.use_openmeteo = True
                                st.success(f"âœ… {len(weather_data)}ä»¶ã®ãƒ‡ãƒ¼ã‚¿ã‚’å–å¾—ã—ã¾ã—ãŸï¼ï¼ˆ{data_source}ï¼‰")

                                # å–å¾—ã—ãŸAPIã®URLã‚’è¡¨ç¤º
                                api_url = f"https://api.open-meteo.com/v1/forecast?latitude={self.weather_api.latitude}&longitude={self.weather_api.longitude}&hourly=temperature_2m,shortwave_radiation&timezone=Asia%2FTokyo&past_days=1"
                                st.info(f"ğŸ”— ä½¿ç”¨API URL: {api_url}")

                                st.rerun()  # ç”»é¢ã‚’æ›´æ–°
                            else:
                                st.error("âŒ ãƒ‡ãƒ¼ã‚¿å–å¾—ã«å¤±æ•—ã—ã¾ã—ãŸï¼ˆãƒ‡ãƒ¼ã‚¿ãŒç©ºã§ã™ï¼‰")
                        except Exception as e:
                            st.error(f"æ°—è±¡ãƒ‡ãƒ¼ã‚¿æ›´æ–°ã‚¨ãƒ©ãƒ¼: {str(e)}")

                # APIãƒ†ã‚¹ãƒˆãƒœã‚¿ãƒ³ã‚’è¿½åŠ 
                if st.button("ğŸ”§ APIæ¥ç¶šãƒ†ã‚¹ãƒˆ", key="test_api_btn_openmeteo"):
                    with st.spinner("APIæ¥ç¶šãƒ†ã‚¹ãƒˆä¸­..."):
                        try:
                            if not hasattr(self, 'weather_api') or self.weather_api is None:
                                self.weather_api = OpenMeteoWeatherAPI()

                            test_result = self.weather_api.test_api_connection()

                            if test_result['success']:
                                st.success("âœ… APIæ¥ç¶šæˆåŠŸï¼")
                                st.info(f"ğŸ“Š Hourlyãƒ‡ãƒ¼ã‚¿: {'æœ‰' if test_result['has_hourly'] else 'ç„¡'}")
                                st.info(f"ğŸ“Š Currentãƒ‡ãƒ¼ã‚¿: {'æœ‰' if test_result['has_current'] else 'ç„¡'}")
                                st.info(f"ğŸ“Š æ—¥å°„é‡ãƒ‡ãƒ¼ã‚¿: {'æœ‰' if test_result['has_shortwave'] else 'ç„¡'}")
                                st.code(f"URL: {test_result['url']}")
                                if 'note' in test_result:
                                    st.info(f"â„¹ï¸ {test_result['note']}")
                            else:
                                st.error(f"âŒ APIæ¥ç¶šå¤±æ•—: {test_result['error']}")
                                st.code(f"è©¦è¡ŒURL: {test_result['url']}")
                                if 'note' in test_result:
                                    st.warning(f"âš ï¸ {test_result['note']}")
                        except Exception as e:
                            st.error(f"ãƒ†ã‚¹ãƒˆã‚¨ãƒ©ãƒ¼: {str(e)}")

            with col2:
                st.write("**ç¾åœ¨ã®å®®å¤å³¶æ°—è±¡æƒ…å ±**")

                # ç¾åœ¨ã®æ°—è±¡ãƒ‡ãƒ¼ã‚¿å–å¾—
                if st.button("ğŸ”„ ç¾åœ¨ã®æ°—è±¡ãƒ‡ãƒ¼ã‚¿ã‚’æ›´æ–°", key="update_current_weather_btn_openmeteo"):
                    with st.spinner("ç¾åœ¨ã®æ°—è±¡ãƒ‡ãƒ¼ã‚¿å–å¾—ä¸­..."):
                        try:
                            # APIåˆæœŸåŒ–ã®ç¢ºèª
                            if not hasattr(self, 'weather_api') or self.weather_api is None:
                                self.weather_api = OpenMeteoWeatherAPI()

                            current_weather = self.weather_api.get_current_weather()

                            if current_weather:
                                st.session_state.current_irradiance = max(0, current_weather['irradiance'])
                                st.session_state.temperature = current_weather['temperature']
                                st.session_state.cloud_cover = current_weather['cloud_cover']

                                st.success("ç¾åœ¨ã®æ°—è±¡ãƒ‡ãƒ¼ã‚¿ã‚’æ›´æ–°ã—ã¾ã—ãŸï¼")

                                # æ›´æ–°ã•ã‚ŒãŸå€¤ã‚’è¡¨ç¤º
                                st.write("**æ›´æ–°ã•ã‚ŒãŸå€¤:**")
                                st.write(f"- æ—¥å°„å¼·åº¦: {current_weather['irradiance']:.3f} kW/mÂ²")
                                st.write(f"- æ°—æ¸©: {current_weather['temperature']:.1f}Â°C")
                                st.write(f"- é›²é‡: {current_weather['cloud_cover']:.0f}%")
                                st.write(f"- æ¹¿åº¦: {current_weather['humidity']:.0f}%")

                                st.rerun()
                            else:
                                st.error("ç¾åœ¨ã®æ°—è±¡ãƒ‡ãƒ¼ã‚¿å–å¾—ã«å¤±æ•—ã—ã¾ã—ãŸ")
                        except Exception as e:
                            st.error(f"æ°—è±¡ãƒ‡ãƒ¼ã‚¿æ›´æ–°ã‚¨ãƒ©ãƒ¼: {str(e)}")

                # ç¾åœ¨å€¤è¡¨ç¤º
                st.write("**ç¾åœ¨ã®è¨­å®šå€¤:**")
                st.metric("æ—¥å°„å¼·åº¦", f"{st.session_state.current_irradiance:.3f} kW/mÂ²")
                st.metric("æ°—æ¸©", f"{st.session_state.temperature:.1f}Â°C")
                st.metric("é›²é‡", f"{st.session_state.cloud_cover:.0f}%")

                if st.session_state.use_openmeteo:
                    st.success("ğŸ“¡ APIé€£æºä¸­")
                else:
                    st.info("ğŸ“ æ‰‹å‹•å…¥åŠ›ä¸­")

            # å–å¾—ã—ãŸãƒ‡ãƒ¼ã‚¿ã®è¡¨ç¤ºã¨äºˆæ¸¬å®Ÿè¡Œ
            if hasattr(st.session_state, 'openmeteo_data') and st.session_state.openmeteo_data is not None:
                st.markdown("---")
                st.write("**ğŸ“‹ å–å¾—ã—ãŸæ°—è±¡ãƒ‡ãƒ¼ã‚¿**")

                # ãƒ‡ãƒ¼ã‚¿ã®æ¦‚è¦è¡¨ç¤º
                data = st.session_state.openmeteo_data

                # ãƒ‡ãƒ¼ã‚¿ãŒå­˜åœ¨ã™ã‚‹ã“ã¨ã‚’ç¢ºèª
                if len(data) > 0:
                    st.write("**ãƒ‡ãƒ¼ã‚¿æ¦‚è¦:**")
                    st.metric("ãƒ‡ãƒ¼ã‚¿ä»¶æ•°", f"{len(data):,}ä»¶")

                    avg_irradiance = data['æ—¥å°„å¼·åº¦'].mean()
                    st.metric("å¹³å‡æ—¥å°„å¼·åº¦", f"{avg_irradiance:.3f} kW/mÂ²")

                    max_irradiance = data['æ—¥å°„å¼·åº¦'].max()
                    st.metric("æœ€å¤§æ—¥å°„å¼·åº¦", f"{max_irradiance:.3f} kW/mÂ²")

                    avg_temp = data['temperature'].mean()
                    st.metric("å¹³å‡æ°—æ¸©", f"{avg_temp:.1f}Â°C")

                    # ãƒ‡ãƒ¼ã‚¿ãƒ†ãƒ¼ãƒ–ãƒ«è¡¨ç¤ºï¼ˆæœ€æ–°50ä»¶ï¼‰
                    st.write("**æœ€æ–°ã®ãƒ‡ãƒ¼ã‚¿ï¼ˆ50ä»¶ï¼‰:**")
                    try:
                        display_cols = []
                        available_cols = ['datetime', 'æ—¥å°„å¼·åº¦', 'temperature', 'cloud_cover', 'humidity']
                        display_names = ['æ™‚åˆ»', 'æ—¥å°„å¼·åº¦(kW/mÂ²)', 'æ°—æ¸©(Â°C)', 'é›²é‡(%)', 'æ¹¿åº¦(%)']

                        # åˆ©ç”¨å¯èƒ½ãªåˆ—ã®ã¿ã‚’é¸æŠ
                        for i, col in enumerate(available_cols):
                            if col in data.columns:
                                display_cols.append(col)

                        if len(display_cols) > 0:
                            display_data = data.tail(50)[display_cols].copy()
                            display_data['datetime'] = display_data['datetime'].dt.strftime('%Y-%m-%d %H:%M')

                            # åˆ—åã‚’æ—¥æœ¬èªã«å¤‰æ›´
                            new_column_names = {}
                            for i, col in enumerate(display_cols):
                                if i < len(display_names):
                                    new_column_names[col] = display_names[i]
                            display_data.rename(columns=new_column_names, inplace=True)

                            st.dataframe(display_data, use_container_width=True)
                        else:
                            st.warning("è¡¨ç¤ºå¯èƒ½ãªåˆ—ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“")
                            st.write("**åˆ©ç”¨å¯èƒ½ãªåˆ—:**", list(data.columns))

                    except Exception as display_error:
                        st.error(f"ãƒ‡ãƒ¼ã‚¿è¡¨ç¤ºã‚¨ãƒ©ãƒ¼: {display_error}")
                        st.write("**åˆ©ç”¨å¯èƒ½ãªåˆ—:**", list(data.columns))

                    # äºˆæ¸¬å®Ÿè¡Œãƒœã‚¿ãƒ³
                    st.write("**äºˆæ¸¬å®Ÿè¡Œè¨­å®š:**")

                    data_points = st.slider(
                        "ä½¿ç”¨ã™ã‚‹ãƒ‡ãƒ¼ã‚¿ç‚¹æ•°",
                        min_value=10,
                        max_value=min(100, len(data)),
                        value=min(50, len(data)),
                        help="æœ€æ–°ãƒ‡ãƒ¼ã‚¿ã‹ã‚‰é¡ã£ã¦ä½¿ç”¨ã™ã‚‹ç‚¹æ•°",
                        key="api_data_points_slider_openmeteo"
                    )

                    if st.button("ğŸš€ Open-Meteoãƒ‡ãƒ¼ã‚¿ã§äºˆæ¸¬å®Ÿè¡Œ", type="primary", key="api_prediction_btn_openmeteo"):
                        with st.spinner("äºˆæ¸¬ãƒ‡ãƒ¼ã‚¿ã‚’æº–å‚™ä¸­..."):
                            try:
                                # æœ€æ–°ã®data_pointsä»¶ã‚’å–å¾—
                                prediction_data = data.tail(data_points).copy()
                                st.info(f"ğŸ“Š å–å¾—ãƒ‡ãƒ¼ã‚¿: {len(prediction_data)}ä»¶")

                                # ç‰¹å¾´é‡ã‚¨ãƒ³ã‚¸ãƒ‹ã‚¢ãƒªãƒ³ã‚°
                                st.info("ğŸ”§ ç‰¹å¾´é‡ã‚¨ãƒ³ã‚¸ãƒ‹ã‚¢ãƒªãƒ³ã‚°å®Ÿè¡Œä¸­...")
                                prediction_data = self.add_time_features(prediction_data)
                                prediction_data = self.add_lag_features(prediction_data)
                                prediction_data = self.add_moving_average_features(prediction_data)
                                prediction_data = self.add_difference_features(prediction_data)

                                # ã‚»ãƒƒã‚·ãƒ§ãƒ³çŠ¶æ…‹ã«ä¿å­˜ã—ã¦å†å®Ÿè¡Œã‚’ä¿ƒã™
                                st.session_state.api_prediction_data = prediction_data

                                st.success(f"âœ… {len(prediction_data)}ä»¶ã®ãƒ‡ãƒ¼ã‚¿ã§äºˆæ¸¬æº–å‚™å®Œäº†")
                                st.info("ğŸ”„ äºˆæ¸¬ã‚’å®Ÿè¡Œã™ã‚‹ãŸã‚ã€ãƒšãƒ¼ã‚¸ã‚’å†èª­ã¿è¾¼ã¿ã—ã¾ã™...")

                                # å¼·åˆ¶çš„ã«å†å®Ÿè¡Œ
                                st.rerun()

                            except Exception as prediction_error:
                                st.error(f"äºˆæ¸¬ãƒ‡ãƒ¼ã‚¿æº–å‚™ã‚¨ãƒ©ãƒ¼: {prediction_error}")
                                st.code(traceback.format_exc())
                                return None
                else:
                    st.error("å–å¾—ã—ãŸãƒ‡ãƒ¼ã‚¿ãŒç©ºã§ã™")
            else:
                st.info("ğŸ’¡ **ä½¿ç”¨æ–¹æ³•:**")
                st.write("1. ä¸Šè¨˜ã®è¨­å®šã§ãƒ‡ãƒ¼ã‚¿æœŸé–“ã‚’é¸æŠ")
                st.write("2. ã€ŒğŸŒ¤ï¸ æ°—è±¡ãƒ‡ãƒ¼ã‚¿ã‚’å–å¾—ã€ãƒœã‚¿ãƒ³ã‚’ã‚¯ãƒªãƒƒã‚¯")
                st.write("3. ãƒ‡ãƒ¼ã‚¿å–å¾—å¾Œã€äºˆæ¸¬å®Ÿè¡Œãƒœã‚¿ãƒ³ãŒè¡¨ç¤ºã•ã‚Œã¾ã™")
                st.warning(
                    "â„¹ï¸ **æ³¨æ„**: å®®å¤å³¶ã§ã¯15åˆ†é–“éš”ãƒ‡ãƒ¼ã‚¿ã¯åˆ©ç”¨ã§ããªã„ãŸã‚ã€1æ™‚é–“é–“éš”ãƒ‡ãƒ¼ã‚¿ã‚’è£œé–“ã—ã¦ä½¿ç”¨ã—ã¾ã™")

            return None

        except Exception as e:
            st.error(f"Open-Meteo APIãƒ•ã‚©ãƒ¼ãƒ ã‚¨ãƒ©ãƒ¼: {str(e)}")
            st.code(traceback.format_exc())
            return None

    def _csv_input_form(self):
        """CSVãƒ•ã‚¡ã‚¤ãƒ«å…¥åŠ›ãƒ•ã‚©ãƒ¼ãƒ """
        st.write("**CSVãƒ•ã‚¡ã‚¤ãƒ«ã‹ã‚‰ãƒ‡ãƒ¼ã‚¿èª­ã¿è¾¼ã¿**")
        uploaded_file = st.file_uploader("CSVãƒ•ã‚¡ã‚¤ãƒ«ã‚’é¸æŠ", type=['csv'])

        if uploaded_file is not None:
            try:
                df = pd.read_csv(uploaded_file, encoding='utf-8')
                st.write("ğŸ“‹ èª­ã¿è¾¼ã¾ã‚ŒãŸãƒ‡ãƒ¼ã‚¿:")
                st.dataframe(df.head(10))

                if st.button("ğŸ“Š CSVãƒ‡ãƒ¼ã‚¿ã§äºˆæ¸¬å®Ÿè¡Œ", type="primary"):
                    return df.head(10)

            except Exception as e:
                st.error(f"ãƒ•ã‚¡ã‚¤ãƒ«èª­ã¿è¾¼ã¿ã‚¨ãƒ©ãƒ¼: {e}")

        return None

    def create_prediction_data_from_input(self):
        """
        å®®å¤å³¶å‘ã‘æ‰‹å‹•å…¥åŠ›ã‹ã‚‰äºˆæ¸¬ç”¨ãƒ‡ãƒ¼ã‚¿ã‚’ä½œæˆï¼ˆæ—¥ç…§æ™‚é–“è€ƒæ…®ç‰ˆï¼‰
        """
        try:
            # åŸºæº–æ—¥æ™‚ã®ä½œæˆ
            base_datetime = datetime.combine(
                st.session_state.prediction_date,
                st.session_state.prediction_time
            )

            # ã‚ˆã‚Šå¤šãã®ã‚µãƒ³ãƒ—ãƒ«ãƒ‡ãƒ¼ã‚¿ç”Ÿæˆï¼ˆç‰¹å¾´é‡è¨ˆç®—ã®ãŸã‚ï¼‰
            num_samples = max(st.session_state.num_points, 50)  # æœ€ä½50ã‚µãƒ³ãƒ—ãƒ«

            data = []
            for i in range(-48, num_samples):  # éå»48ãƒã‚¤ãƒ³ãƒˆã‹ã‚‰ç¾åœ¨ã¾ã§
                dt = base_datetime + timedelta(minutes=i*15)

                # å®®å¤å³¶ã®æ—¥ç…§æ™‚é–“ã‚’è€ƒæ…®ï¼ˆæ—¥ã®å‡º: 6:00ã€æ—¥ã®å…¥ã‚Š: 18:30é ƒï¼‰
                hour = dt.hour + dt.minute / 60.0

                # æ—¥å°„å¼·åº¦ã®æ™‚é–“ãƒ‘ã‚¿ãƒ¼ãƒ³ï¼ˆå¤œé–“ã¯0ï¼‰
                if hour < 6.0 or hour > 18.5:
                    # å¤œé–“ã¯æ—¥å°„å¼·åº¦0
                    hour_factor = 0.0
                else:
                    # æ—¥ä¸­ã®æ—¥å°„ãƒ‘ã‚¿ãƒ¼ãƒ³ï¼ˆæ­£å¼¦æ³¢ï¼‰
                    solar_hour = (hour - 6.0) / 12.5  # 6:00ã‚’0ã€18:30ã‚’1ã¨ã™ã‚‹æ­£è¦åŒ–
                    hour_factor = max(0, np.sin(np.pi * solar_hour))

                # å­£ç¯€å¤‰å‹•
                day_of_year = dt.timetuple().tm_yday
                seasonal_factor = 0.8 + 0.2 * np.cos(2 * np.pi * (day_of_year - 180) / 365)

                # ç¾åœ¨ã®å…¥åŠ›å€¤ã«åŸºã¥ãèª¿æ•´
                base_irradiance = st.session_state.current_irradiance
                base_pv = st.session_state.current_pv

                # æ™‚é–“ã¨ãƒ‘ã‚¿ãƒ¼ãƒ³ã«åŸºã¥ãå€¤ã®ç”Ÿæˆ
                if hour_factor > 0:
                    # æ—¥ä¸­ã®å ´åˆ
                    irradiance = base_irradiance * hour_factor * seasonal_factor + np.random.normal(0, 0.03)
                    irradiance = max(0, min(1.2, irradiance))

                    pv_output = base_pv * hour_factor * seasonal_factor + np.random.normal(0, 2.0)
                    pv_output = max(0, min(st.session_state.pv_capacity, pv_output))
                else:
                    # å¤œé–“ã®å ´åˆ
                    irradiance = 0.0
                    pv_output = 0.0

                data.append({
                    'datetime': dt,
                    'æ—¥å°„å¼·åº¦': irradiance,
                    'PVå‡ºåŠ›': pv_output,
                    'æ°—æ¸©': st.session_state.temperature + np.random.normal(0, 1),
                    'æ¹¿åº¦': 75.0 + np.random.normal(0, 3)  # å®®å¤å³¶ã®é«˜æ¹¿åº¦
                })

            input_data = pd.DataFrame(data)

            # å¤©å€™ã«å¿œã˜ãŸèª¿æ•´ï¼ˆå¤œé–“ä»¥å¤–ã®ã¿ï¼‰
            weather_factors = {
                "æ™´ã‚Œ": 1.0,
                "æ›‡ã‚Š": 0.7,
                "é›¨": 0.3,
                "ãã®ä»–": 0.5
            }

            factor = weather_factors.get(st.session_state.weather_condition, 0.5)
            # æ—¥å°„å¼·åº¦ãŒ0ã§ãªã„å ´åˆã®ã¿å¤©å€™è£œæ­£ã‚’é©ç”¨
            mask = input_data['æ—¥å°„å¼·åº¦'] > 0
            input_data.loc[mask, 'æ—¥å°„å¼·åº¦'] *= factor
            input_data.loc[mask, 'PVå‡ºåŠ›'] *= factor

            # ç‰¹å¾´é‡ã‚¨ãƒ³ã‚¸ãƒ‹ã‚¢ãƒªãƒ³ã‚°ã®è¿½åŠ 
            input_data = self.add_time_features(input_data)
            input_data = self.add_lag_features(input_data)
            input_data = self.add_moving_average_features(input_data)
            input_data = self.add_difference_features(input_data)
            # äºˆæ¸¬ç”¨ã«æœ€æ–°ã®num_pointsã ã‘ã‚’è¿”ã™
            return input_data.tail(st.session_state.num_points).reset_index(drop=True)

        except Exception as e:
            st.error(f"ãƒ‡ãƒ¼ã‚¿ä½œæˆã‚¨ãƒ©ãƒ¼: {e}")
            import traceback
            st.code(f"Error details: {traceback.format_exc()}")
            return None

    def add_time_features(self, df):
        """æ™‚é–“ç‰¹å¾´é‡ã®è¿½åŠ """
        try:
            df['hour'] = df['datetime'].dt.hour
            df['minute'] = df['datetime'].dt.minute
            df['day_of_year'] = df['datetime'].dt.dayofyear
            df['day_of_week'] = df['datetime'].dt.dayofweek

            # å‘¨æœŸçš„ç‰¹å¾´é‡
            df['hour_sin'] = np.sin(2 * np.pi * df['hour'] / 24)
            df['hour_cos'] = np.cos(2 * np.pi * df['hour'] / 24)
            df['day_sin'] = np.sin(2 * np.pi * df['day_of_year'] / 365)
            df['day_cos'] = np.cos(2 * np.pi * df['day_of_year'] / 365)

            return df
        except Exception as e:
            st.error(f"æ™‚é–“ç‰¹å¾´é‡è¿½åŠ ã‚¨ãƒ©ãƒ¼: {e}")
            return df

    def add_lag_features(self, df):
        """ãƒ©ã‚°ç‰¹å¾´é‡ã®è¿½åŠ """
        try:
            lags = [1, 2, 3, 4, 8, 12, 24, 48]

            for lag in lags:
                df[f'irradiance_lag_{lag}'] = df['æ—¥å°„å¼·åº¦'].shift(lag)
                df[f'pv_lag_{lag}'] = df['PVå‡ºåŠ›'].shift(lag)

            # æ¬ æå€¤ã‚’å‰æ–¹åŸ‹ã‚ã§è£œå®Œ
            for lag in lags:
                df[f'irradiance_lag_{lag}'].fillna(df['æ—¥å°„å¼·åº¦'].iloc[0], inplace=True)
                df[f'pv_lag_{lag}'].fillna(df['PVå‡ºåŠ›'].iloc[0], inplace=True)

            return df
        except Exception as e:
            st.error(f"ãƒ©ã‚°ç‰¹å¾´é‡è¿½åŠ ã‚¨ãƒ©ãƒ¼: {e}")
            return df

    def add_moving_average_features(self, df):
        """ç§»å‹•å¹³å‡ç‰¹å¾´é‡ã®è¿½åŠ """
        try:
            windows = [4, 8, 12, 24]

            for window in windows:
                df[f'irradiance_ma_{window}'] = df['æ—¥å°„å¼·åº¦'].rolling(window=window, min_periods=1).mean()
                df[f'pv_ma_{window}'] = df['PVå‡ºåŠ›'].rolling(window=window, min_periods=1).mean()

            return df
        except Exception as e:
            st.error(f"ç§»å‹•å¹³å‡ç‰¹å¾´é‡è¿½åŠ ã‚¨ãƒ©ãƒ¼: {e}")
            return df

    def add_difference_features(self, df):
        """å·®åˆ†ç‰¹å¾´é‡ã®è¿½åŠ """
        try:
            diffs = [1, 4]

            for diff in diffs:
                df[f'irradiance_diff_{diff}'] = df['æ—¥å°„å¼·åº¦'].diff(diff)
                if diff == 1:  # pv_diff_1ã®ã¿è¿½åŠ 
                    df[f'pv_diff_{diff}'] = df['PVå‡ºåŠ›'].diff(diff)

            # æ¬ æå€¤ã‚’0ã§åŸ‹ã‚ã‚‹
            for diff in diffs:
                df[f'irradiance_diff_{diff}'].fillna(0, inplace=True)
                if diff == 1:
                    df[f'pv_diff_{diff}'].fillna(0, inplace=True)

            return df
        except Exception as e:
            st.error(f"å·®åˆ†ç‰¹å¾´é‡è¿½åŠ ã‚¨ãƒ©ãƒ¼: {e}")
            return df

    def reset_input_values(self):
        """å…¥åŠ›å€¤ã‚’ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã«ãƒªã‚»ãƒƒãƒˆ"""
        st.session_state.prediction_date = datetime.now().date()
        st.session_state.prediction_time = datetime.now().time()
        st.session_state.num_points = 3
        st.session_state.current_irradiance = 0.5
        st.session_state.current_pv = 40.0
        st.session_state.weather_condition = "æ™´ã‚Œ"
        st.session_state.cloud_cover = 30
        st.session_state.temperature = 23.6  # å®®å¤å³¶å¹³å‡æ°—æ¸©
        st.session_state.forecast_steps = ["15åˆ†å…ˆ", "30åˆ†å…ˆ", "1æ™‚é–“å…ˆ"]
        st.session_state.season_factor = "æ˜¥å­£ï¼ˆ3-5æœˆï¼‰"
        st.session_state.weather_risk = "å¹³å¸¸æ™‚"
        st.session_state.operational_rate = 95.0

    def save_current_settings(self):
        """ç¾åœ¨ã®è¨­å®šã‚’ãƒ•ã‚¡ã‚¤ãƒ«ã«ä¿å­˜"""
        settings = {
            'current_irradiance': st.session_state.current_irradiance,
            'current_pv': st.session_state.current_pv,
            'weather_condition': st.session_state.weather_condition,
            'cloud_cover': st.session_state.cloud_cover,
            'temperature': st.session_state.temperature,
            'forecast_steps': st.session_state.forecast_steps,
            'num_points': st.session_state.num_points,
            'season_factor': st.session_state.season_factor,
            'weather_risk': st.session_state.weather_risk,
            'operational_rate': st.session_state.operational_rate,
            'pv_capacity': st.session_state.pv_capacity
        }

        try:
            with open('miyako_pv_app_settings.json', 'w', encoding='utf-8') as f:
                json.dump(settings, f, ensure_ascii=False, indent=2, default=str)
        except Exception as e:
            st.error(f"è¨­å®šä¿å­˜ã‚¨ãƒ©ãƒ¼: {e}")


def create_prediction_chart_with_historical(input_data, predictions, forecast_labels, pv_capacity,
                                            historical_data=None):
    """
    å®®å¤å³¶å‘ã‘äºˆæ¸¬çµæœã®çµ±åˆã‚°ãƒ©ãƒ•ä½œæˆï¼ˆéå»å®Ÿç¸¾è¡¨ç¤ºå¯¾å¿œç‰ˆï¼‰
    """
    fig = go.Figure()

    # åŸºæº–æ™‚åˆ»ã®å–å¾—
    if hasattr(st.session_state, 'prediction_date') and hasattr(st.session_state, 'prediction_time'):
        base_time = datetime.combine(st.session_state.prediction_date, st.session_state.prediction_time)
    else:
        base_time = input_data['datetime'].iloc[-1] if len(input_data) > 0 else datetime.now()

# **1. éå»ã®æ—¥å°„å®Ÿç¸¾ãƒ‡ãƒ¼ã‚¿ã®è¡¨ç¤ºï¼ˆOpen-Meteoãƒ‡ãƒ¼ã‚¿ï¼‰**
if historical_data is not None and len(historical_data) > 0:
    try:
        # éå»ãƒ‡ãƒ¼ã‚¿ã‚’åŸºæº–æ™‚åˆ»ã‚ˆã‚Šå‰ã®ã‚‚ã®ã«é™å®š
        past_data = historical_data[historical_data['datetime'] < base_time].copy()

        if len(past_data) > 0:
            # éå»ã®æ—¥å°„å¼·åº¦å®Ÿç¸¾
            fig.add_trace(go.Scatter(
                x=past_data['datetime'],  # âœ…ã€ä¿®æ­£ã€‘æ­£ã—ã„å¤‰æ•°ã‚’ä½¿ç”¨
                y=past_data['æ—¥å°„å¼·åº¦'],  # âœ…ã€ä¿®æ­£ã€‘æ­£ã—ã„å¤‰æ•°ã‚’ä½¿ç”¨
                mode='lines',
                name='ğŸ“ˆ éå»æ—¥å°„å®Ÿç¸¾ï¼ˆOpen-Meteoï¼‰',
                line=dict(color='red', width=3, dash='dash'),
                marker=dict(size=8, color='red'),
                connectgaps=True,
                hovertemplate='<b>äºˆæ¸¬å€¤</b><br>' +
                                  'æ™‚åˆ»: %{x}<br>' +
                                  'äºˆæ¸¬æ—¥å°„å¼·åº¦: %{y:.3f} kW/mÂ²<extra></extra>'
                ))
                # éå»ã®PVå‡ºåŠ›å®Ÿç¸¾
                fig.add_trace(go.Scatter(
                x=past_data['datetime'],
                y=past_data['PVå‡ºåŠ›'],
                mode='lines',
                name='âš¡ éå»PVå‡ºåŠ›å®Ÿç¸¾',
                line=dict(color='lightgreen', width=2),
                opacity=0.7,
                yaxis='y2',
                hovertemplate='<b>éå»PVå®Ÿç¸¾</b><br>' +
                                  'æ™‚åˆ»: %{x}<br>' +
                                  'PVå‡ºåŠ›: %{y:.1f} MW<extra></extra>'
                ))

                # çµ±è¨ˆæƒ…å ±ã®è¡¨ç¤º
                avg_past_irradiance = past_data['æ—¥å°„å¼·åº¦'].mean()
                max_past_irradiance = past_data['æ—¥å°„å¼·åº¦'].max()

                st.info(f"ğŸ“Š **éå»å®Ÿç¸¾çµ±è¨ˆï¼ˆ{len(past_data)}ä»¶ï¼‰**")
                st.write(f"- å¹³å‡æ—¥å°„å¼·åº¦: {avg_past_irradiance:.3f} kW/mÂ²")
                st.write(f"- æœ€å¤§æ—¥å°„å¼·åº¦: {max_past_irradiance:.3f} kW/mÂ²")
                st.write(
                        f"- ãƒ‡ãƒ¼ã‚¿æœŸé–“: {past_data['datetime'].min().strftime('%m/%d %H:%M')} ã€œ {past_data['datetime'].max().strftime('%m/%d %H:%M')}")

                except Exception as hist_error:
                st.warning(f"éå»ãƒ‡ãƒ¼ã‚¿è¡¨ç¤ºã‚¨ãƒ©ãƒ¼: {hist_error}")

    # **2. ç¾åœ¨ã®æ—¥å°„å¼·åº¦**
    fig.add_trace(go.Scatter(
        x=input_data['datetime'],
        y=input_data['æ—¥å°„å¼·åº¦'],
        mode='lines+markers',
        name='ğŸŒ ç¾åœ¨ã®æ—¥å°„å¼·åº¦',
        line=dict(color='blue', width=3),
        marker=dict(size=8, color='blue'),
        hovertemplate='<b>ç¾åœ¨ãƒ‡ãƒ¼ã‚¿</b><br>' +
                      'æ™‚åˆ»: %{x}<br>' +
                      'æ—¥å°„å¼·åº¦: %{y:.3f} kW/mÂ²<extra></extra>'
    ))

    # **3. ç¾åœ¨ã®PVå‡ºåŠ›**
    fig.add_trace(go.Scatter(
        x=input_data['datetime'],
        y=input_data['PVå‡ºåŠ›'],
        mode='lines+markers',
        name='ğŸ”‹ ç¾åœ¨ã®PVå‡ºåŠ› (MW)',
        line=dict(color='green', width=3),
        marker=dict(size=8, color='green'),
        yaxis='y2',
        hovertemplate='<b>ç¾åœ¨PVå‡ºåŠ›</b><br>' +
                      'æ™‚åˆ»: %{x}<br>' +
                      'PVå‡ºåŠ›: %{y:.1f} MW<extra></extra>'
    ))

    # **4. äºˆæ¸¬ãƒ‡ãƒ¼ã‚¿ã®å‡¦ç†ã¨è¡¨ç¤º**
    if predictions and len(predictions) > 0:
        try:
            # äºˆæ¸¬æ™‚é–“è»¸ã‚’ã‚½ãƒ¼ãƒˆ
            sorted_predictions = sorted(predictions.items(), key=lambda x: int(x[0].replace('min', '')))

            # äºˆæ¸¬ãƒ‡ãƒ¼ã‚¿ã®çµ±åˆ
            future_times = []
            future_irradiance = []
            future_pv_output = []

            for time_key, pred_values in sorted_predictions:
                try:
                    minutes_ahead = int(time_key.replace('min', ''))

                    if pred_values is not None and hasattr(pred_values, '__len__') and len(pred_values) > 0:
                        # äºˆæ¸¬æ™‚åˆ»
                        future_time = base_time + timedelta(minutes=minutes_ahead)
                        future_times.append(future_time)

                        # äºˆæ¸¬å€¤ã®è¨ˆç®—
                        if isinstance(pred_values, (list, tuple)):
                            avg_irradiance = np.mean([float(v) for v in pred_values])
                        elif isinstance(pred_values, np.ndarray):
                            avg_irradiance = float(np.mean(pred_values))
                        else:
                            avg_irradiance = float(pred_values)

                        future_irradiance.append(avg_irradiance)

                        # PVå‡ºåŠ›äºˆæ¸¬
                        efficiency = getattr(st.session_state, 'total_efficiency', 0.16)
                        pv_pred = avg_irradiance * pv_capacity * efficiency
                        future_pv_output.append(pv_pred)

                except Exception as item_error:
                    continue

            # **5. äºˆæ¸¬ç·šã®è¡¨ç¤ºï¼ˆç¾åœ¨â†’æœªæ¥ã¸ã®é€£ç¶šç·šï¼‰**
            if len(future_times) > 0:
                try:
                    current_irradiance = float(st.session_state.current_irradiance)
                    current_pv = float(st.session_state.current_pv)
                except:
                    current_irradiance = 0.5
                    current_pv = 40.0

# æ—¥å°„å¼·åº¦äºˆæ¸¬ç·š
combined_times = [base_time] + future_times
combined_irradiance = [current_irradiance] + future_irradiance

fig.add_trace(go.Scatter(
    x=combined_times,  # âœ…ã€ä¿®æ­£ã€‘æ­£ã—ã„äºˆæ¸¬æ™‚é–“è»¸
    y=combined_irradiance,  # âœ…ã€ä¿®æ­£ã€‘æ­£ã—ã„äºˆæ¸¬å€¤
    mode='lines+markers',
    name='ğŸ”® æ—¥å°„å¼·åº¦äºˆæ¸¬',
                    line=dict(color='lightblue', width=2),
                    opacity=0.7,
                    hovertemplate='<b>éå»å®Ÿç¸¾</b><br>' +
                                  'æ™‚åˆ»: %{x}<br>' +
                                  'æ—¥å°„å¼·åº¦: %{y:.3f} kW/mÂ²<extra></extra>'
                ))

                # PVå‡ºåŠ›äºˆæ¸¬ç·š
                combined_pv = [current_pv] + future_pv_output

                fig.add_trace(go.Scatter(
                    x=combined_times,
                    y=combined_pv,
                    mode='lines+markers',
                    name='âš¡ PVå‡ºåŠ›äºˆæ¸¬ (MW)',
                    line=dict(color='orange', width=3, dash='dash'),
                    marker=dict(size=8, color='orange'),
                    yaxis='y2',
                    connectgaps=True,
                    hovertemplate='<b>PVäºˆæ¸¬</b><br>' +
                                  'æ™‚åˆ»: %{x}<br>' +
                                  'äºˆæ¸¬PVå‡ºåŠ›: %{y:.1f} MW<extra></extra>'
                ))

                # **6. äºˆæ¸¬ä¿¡é ¼åŒºé–“ã®è¡¨ç¤º**
                if len(future_times) > 1:
                    try:
                        uncertainty = 0.15  # 15%ã®ä¸ç¢ºå®Ÿæ€§
                        upper_irradiance = [float(val) * (1 + uncertainty) for val in future_irradiance]
                        lower_irradiance = [float(val) * (1 - uncertainty) for val in future_irradiance]

                        fig.add_trace(go.Scatter(
                            x=future_times + future_times[::-1],
                            y=upper_irradiance + lower_irradiance[::-1],
                            fill='toself',
                            fillcolor='rgba(255, 0, 0, 0.1)',
                            line=dict(color='rgba(255, 255, 255, 0)'),
                            name='ğŸ“Š äºˆæ¸¬ä¿¡é ¼åŒºé–“',
                            showlegend=True,
                            hoverinfo='skip'
                        ))
                    except Exception as confidence_error:
                        pass

        except Exception as predictions_error:
            st.warning("äºˆæ¸¬ãƒ‡ãƒ¼ã‚¿ã®å‡¦ç†ä¸­ã«ã‚¨ãƒ©ãƒ¼ãŒç™ºç”Ÿã—ã¾ã—ãŸ")

    # **7. ç¾åœ¨æ™‚åˆ»ã®å‚ç›´ç·š**
    fig.add_vline(
        x=base_time,
        line_dash="dot",
        line_color="black",
        line_width=2,
        annotation_text="ğŸ“ ç¾åœ¨æ™‚åˆ»",
        annotation_position="top"
    )

    # **8. æ—¥ã®å‡ºãƒ»æ—¥ã®å…¥ã‚Šæ™‚åˆ»ã®è¡¨ç¤ºï¼ˆå®®å¤å³¶ï¼‰**
    try:
        # å®®å¤å³¶ã®æ¦‚ç®—æ—¥ã®å‡ºãƒ»æ—¥ã®å…¥ã‚Šæ™‚åˆ»
        sunrise_time = base_time.replace(hour=6, minute=30, second=0, microsecond=0)
        sunset_time = base_time.replace(hour=18, minute=30, second=0, microsecond=0)

        fig.add_vline(
            x=sunrise_time,
            line_dash="dashdot",
            line_color="gold",
            line_width=1,
            annotation_text="ğŸŒ… æ—¥ã®å‡º",
            annotation_position="bottom left"
        )

        fig.add_vline(
            x=sunset_time,
            line_dash="dashdot",
            line_color="darkorange",
            line_width=1,
            annotation_text="ğŸŒ… æ—¥ã®å…¥ã‚Š",
            annotation_position="bottom right"
        )
    except:
        pass

    # **9. ãƒ¬ã‚¤ã‚¢ã‚¦ãƒˆè¨­å®š**
    try:
        # Xè»¸ã®ç¯„å›²è¨­å®š
        if predictions and len(predictions) > 0:
            max_minutes = max([int(key.replace('min', '')) for key in predictions.keys()])
            future_end_time = base_time + timedelta(minutes=max_minutes + 30)
        else:
            future_end_time = base_time + timedelta(hours=2)

        # éå»ãƒ‡ãƒ¼ã‚¿ãŒã‚ã‚‹å ´åˆã¯é–‹å§‹æ™‚åˆ»ã‚’èª¿æ•´
        if historical_data is not None and len(historical_data) > 0:
            past_start_time = historical_data['datetime'].min()
            start_time = min(past_start_time, base_time - timedelta(hours=2))
        else:
            start_time = base_time - timedelta(hours=1)

        fig.update_layout(
            title={
                'text': f"ğŸï¸ å®®å¤å³¶å…¨åœŸ PVå‡ºåŠ›çµ±åˆäºˆæ¸¬ <br><sub>åŸºæº–æ™‚åˆ»: {base_time.strftime('%Y-%m-%d %H:%M')} | å®¹é‡: {pv_capacity:.0f}MW</sub>",
                'x': 0.5,
                'font': {'size': 16}
            },
            xaxis_title="æ™‚åˆ»",
            yaxis_title="æ—¥å°„å¼·åº¦ (kW/mÂ²)",
            yaxis2=dict(
                title="PVå‡ºåŠ› (MW)",
                overlaying='y',
                side='right',
                showgrid=False
            ),
            xaxis=dict(
                range=[start_time, future_end_time],
                tickformat='%m/%d %H:%M',
                dtick=60 * 60 * 1000,  # 1æ™‚é–“ã”ã¨
                showgrid=True,
                gridcolor='lightgray'
            ),
            yaxis=dict(
                showgrid=True,
                gridcolor='lightgray'
            ),
            hovermode='x unified',
            template='plotly_white',
            height=600,
            legend=dict(
                orientation="h",
                yanchor="bottom",
                y=-0.15,
                xanchor="center",
                x=0.5,
                font={'size': 10}
            ),
            margin=dict(b=100)  # ä¸‹éƒ¨ãƒãƒ¼ã‚¸ãƒ³ã‚’å¢—ã‚„ã—ã¦å‡¡ä¾‹ã®ã‚¹ãƒšãƒ¼ã‚¹ã‚’ç¢ºä¿
        )

        # ã‚°ãƒªãƒƒãƒ‰ã¨ã‚¹ã‚¿ã‚¤ãƒ«ã®èª¿æ•´
        fig.update_traces(line_width=2)

    except Exception as layout_error:
        # ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯ï¼šåŸºæœ¬ãƒ¬ã‚¤ã‚¢ã‚¦ãƒˆ
        fig.update_layout(
            title="ğŸï¸ å®®å¤å³¶å…¨åœŸ PVå‡ºåŠ›çµ±åˆäºˆæ¸¬",
            xaxis_title="æ™‚åˆ»",
            yaxis_title="æ—¥å°„å¼·åº¦ (kW/mÂ²)",
            template='plotly_white',
            height=600
        )

    return fig


def create_prediction_chart_with_capacity(input_data, predictions, forecast_labels, pv_capacity):
    """
    åŸºæœ¬çš„ãªäºˆæ¸¬çµæœã‚°ãƒ©ãƒ•ä½œæˆï¼ˆãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯ç”¨ï¼‰
    """
    fig = go.Figure()

    # åŸºæº–æ™‚åˆ»ã®å–å¾—
    if hasattr(st.session_state, 'prediction_date') and hasattr(st.session_state, 'prediction_time'):
        base_time = datetime.combine(st.session_state.prediction_date, st.session_state.prediction_time)
    else:
        base_time = input_data['datetime'].iloc[-1] if len(input_data) > 0 else datetime.now()

    # ç¾åœ¨ã®æ—¥å°„å¼·åº¦
    fig.add_trace(go.Scatter(
        x=input_data['datetime'],
        y=input_data['æ—¥å°„å¼·åº¦'],
        mode='lines+markers',
        name='ğŸŒ ç¾åœ¨ã®æ—¥å°„å¼·åº¦',
        line=dict(color='blue', width=3),
        marker=dict(size=8, color='blue')
    ))

    # ç¾åœ¨ã®PVå‡ºåŠ›
    fig.add_trace(go.Scatter(
        x=input_data['datetime'],
        y=input_data['PVå‡ºåŠ›'],
        mode='lines+markers',
        name='ğŸ”‹ ç¾åœ¨ã®PVå‡ºåŠ› (MW)',
        line=dict(color='green', width=3),
        marker=dict(size=8, color='green'),
        yaxis='y2'
    ))

    # äºˆæ¸¬ãƒ‡ãƒ¼ã‚¿ã®è¿½åŠ 
    if predictions:
        for time_key, pred_values in predictions.items():
            if pred_values:
                minutes_ahead = int(time_key.replace('min', ''))
                future_time = base_time + timedelta(minutes=minutes_ahead)
                
                avg_irradiance = np.mean(pred_values) if isinstance(pred_values, (list, np.ndarray)) else pred_values
                
                fig.add_trace(go.Scatter(
                    x=[future_time],
                    y=[avg_irradiance],
                    mode='markers',
                    name=f'ğŸ”® {time_key}äºˆæ¸¬',
                    marker=dict(size=12, color='red')
                ))

    # ãƒ¬ã‚¤ã‚¢ã‚¦ãƒˆè¨­å®š
    fig.update_layout(
        title=f"ğŸï¸ å®®å¤å³¶PVå‡ºåŠ›äºˆæ¸¬ (å®¹é‡: {pv_capacity:.0f}MW)",
        xaxis_title="æ™‚åˆ»",
        yaxis_title="æ—¥å°„å¼·åº¦ (kW/mÂ²)",
        yaxis2=dict(
            title="PVå‡ºåŠ› (MW)",
            overlaying='y',
            side='right'
        ),
        template='plotly_white',
        height=500
    )

    return fig


def main():
    """
    ãƒ¡ã‚¤ãƒ³ã‚¢ãƒ—ãƒªã‚±ãƒ¼ã‚·ãƒ§ãƒ³ï¼ˆå®®å¤å³¶å¯¾å¿œç‰ˆï¼‰
    """
    # æœ€åˆã«ã‚»ãƒƒã‚·ãƒ§ãƒ³çŠ¶æ…‹ã‚’åˆæœŸåŒ–
    init_streamlit_session()

    # PVäºˆæ¸¬å™¨ã®åˆæœŸåŒ–
    predictor = StreamlitPVPredictor()

    # ãƒ˜ãƒƒãƒ€ãƒ¼
    st.markdown("""
    <div class="main-header">
        ğŸï¸ å®®å¤å³¶PVå‡ºåŠ›äºˆæ¸¬ã‚·ã‚¹ãƒ†ãƒ  âš¡
    </div>
    """, unsafe_allow_html=True)

    # ã‚µã‚¤ãƒ‰ãƒãƒ¼ï¼šãƒ¢ãƒ‡ãƒ«è¨­å®š
    st.sidebar.title("ğŸ¤– ãƒ¢ãƒ‡ãƒ«è¨­å®š")

    # å­¦ç¿’æ¸ˆã¿ãƒ¢ãƒ‡ãƒ«ãƒ•ã‚©ãƒ«ãƒ€ã®é¸æŠ
    model_folders = []
    current_dir = Path(".")
    for item in current_dir.iterdir():
        if item.is_dir() and "pv_models" in item.name:
            model_folders.append(str(item))

    # ãƒ¢ãƒ‡ãƒ«ãƒ•ã‚©ãƒ«ãƒ€ãŒè¦‹ã¤ã‹ã‚‰ãªã„å ´åˆã¯ãƒ‡ãƒ¢ãƒ•ã‚©ãƒ«ãƒ€ã‚’ä½œæˆ
    if not model_folders:
        model_folders = ["miyako_demo_models"]
        st.sidebar.warning("å­¦ç¿’æ¸ˆã¿ãƒ¢ãƒ‡ãƒ«ãƒ•ã‚©ãƒ«ãƒ€ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“ã€‚å®®å¤å³¶ãƒ‡ãƒ¢ãƒ¢ãƒ¼ãƒ‰ã§å‹•ä½œã—ã¾ã™ã€‚")

    # ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆå€¤ã®å®‰å…¨ãªè¨­å®š
    default_model_index = 0
    if st.session_state.selected_model and st.session_state.selected_model in model_folders:
        default_model_index = model_folders.index(st.session_state.selected_model)

    st.session_state.selected_model = st.sidebar.selectbox(
        "ä½¿ç”¨ãƒ¢ãƒ‡ãƒ«",
        model_folders,
        index=default_model_index,
        help="å­¦ç¿’æ¸ˆã¿ãƒ¢ãƒ‡ãƒ«ãƒ•ã‚©ãƒ«ãƒ€ã‚’é¸æŠ"
    )

    # äºˆæ¸¬ãƒ¢ãƒ‡ãƒ«ã®é¸æŠ
    model_options = ["random_forest", "xgboost", "gradient_boosting", "ridge", "linear"]
    default_model_type_index = 0
    if st.session_state.model_type in model_options:
        default_model_type_index = model_options.index(st.session_state.model_type)

    st.session_state.model_type = st.sidebar.selectbox(
        "äºˆæ¸¬ã‚¢ãƒ«ã‚´ãƒªã‚ºãƒ ",
        model_options,
        index=default_model_type_index,
        help="ä½¿ç”¨ã™ã‚‹æ©Ÿæ¢°å­¦ç¿’ã‚¢ãƒ«ã‚´ãƒªã‚ºãƒ "
    )

    # äºˆæ¸¬æ™‚é–“è»¸ã®é¸æŠ
    forecast_options = {
        "15åˆ†å…ˆ": 1,
        "30åˆ†å…ˆ": 2,
        "45åˆ†å…ˆ": 3,
        "1æ™‚é–“å…ˆ": 4,
        "2æ™‚é–“å…ˆ": 8,
        "3æ™‚é–“å…ˆ": 12,
        "6æ™‚é–“å…ˆ": 24
    }

    # ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆå€¤ã®å®‰å…¨ãªè¨­å®š
    default_forecasts = ["15åˆ†å…ˆ", "30åˆ†å…ˆ", "1æ™‚é–“å…ˆ"]
    if st.session_state.forecast_steps:
        default_forecasts = st.session_state.forecast_steps

    st.session_state.forecast_steps = st.sidebar.multiselect(
        "äºˆæ¸¬æ™‚é–“è»¸",
        list(forecast_options.keys()),
        default=default_forecasts,
        help="äºˆæ¸¬ã—ãŸã„æ™‚é–“è»¸ã‚’é¸æŠ"
    )

    forecast_steps = [forecast_options[key] for key in st.session_state.forecast_steps]

    # Open-Meteo APIè¨­å®šã‚’ã‚µã‚¤ãƒ‰ãƒãƒ¼ã«è¿½åŠ 
    st.sidebar.markdown("---")
    st.sidebar.subheader("ğŸŒ APIè¨­å®š")

    st.session_state.api_enabled = st.sidebar.checkbox(
        "Open-Meteo APIä½¿ç”¨",
        value=st.session_state.api_enabled,
        help="å®Ÿéš›ã®æ°—è±¡ãƒ‡ãƒ¼ã‚¿ã‚’å–å¾—ã—ã¦ã‚ˆã‚Šç²¾åº¦ã®é«˜ã„äºˆæ¸¬ã‚’è¡Œã„ã¾ã™"
    )

    if st.session_state.api_enabled:
        st.sidebar.success("âœ… APIæ©Ÿèƒ½ãŒæœ‰åŠ¹ã§ã™")

        # APIæ¥ç¶šãƒ†ã‚¹ãƒˆ
        if st.sidebar.button("ğŸ”— APIæ¥ç¶šãƒ†ã‚¹ãƒˆ"):
            with st.spinner("APIæ¥ç¶šç¢ºèªä¸­..."):
                try:
                    weather_api = OpenMeteoWeatherAPI()
                    current_weather = weather_api.get_current_weather()
                    if current_weather:
                        st.sidebar.success("âœ… APIæ¥ç¶šæˆåŠŸï¼")
                        st.sidebar.info(f"ç¾åœ¨ã®å®®å¤å³¶æ°—æ¸©: {current_weather['temperature']:.1f}Â°C")
                    else:
                        st.sidebar.error("âŒ APIæ¥ç¶šå¤±æ•—")
                except Exception as e:
                    st.sidebar.error(f"âŒ APIæ¥ç¶šã‚¨ãƒ©ãƒ¼: {str(e)[:50]}...")
    else:
        st.sidebar.info("â„¹ï¸ æ‰‹å‹•å…¥åŠ›ãƒ¢ãƒ¼ãƒ‰ã§ã™")

    # ãƒ‡ãƒ¼ã‚¿ã‚½ãƒ¼ã‚¹è¡¨ç¤º
    if st.session_state.use_openmeteo and hasattr(st.session_state, 'openmeteo_data'):
        st.sidebar.success(f"ğŸ“¡ APIå–å¾—ãƒ‡ãƒ¼ã‚¿: {len(st.session_state.openmeteo_data)}ä»¶")
    else:
        st.sidebar.info("ğŸ“ æ‰‹å‹•å…¥åŠ›ãƒ‡ãƒ¼ã‚¿ä½¿ç”¨ä¸­")

    # ãƒ¢ãƒ‡ãƒ«èª­ã¿è¾¼ã¿
    with st.spinner("ğŸ¤– ãƒ¢ãƒ‡ãƒ«èª­ã¿è¾¼ã¿ä¸­..."):
        loaded_predictor, model_info = predictor.load_model(st.session_state.selected_model)

    if loaded_predictor is None:
        st.error("ãƒ¢ãƒ‡ãƒ«ã®èª­ã¿è¾¼ã¿ã«å¤±æ•—ã—ã¾ã—ãŸ")
        return

    # ãƒ¢ãƒ‡ãƒ«æƒ…å ±è¡¨ç¤º
    if model_info:
        with st.sidebar.expander("ğŸ“Š ãƒ¢ãƒ‡ãƒ«æƒ…å ±"):
            st.write(f"**ä¿å­˜æ—¥æ™‚:** {model_info.get('save_date', 'N/A')}")
            st.write(f"**ãƒ‡ãƒ¼ã‚¿ä»¶æ•°:** {model_info.get('data_info', {}).get('total_samples', 'N/A'):,}ä»¶")
            st.write(f"**ç‰¹å¾´é‡æ•°:** {len(model_info.get('feature_columns', []))}")
            st.write(f"**å¯¾è±¡åœ°åŸŸ:** {model_info.get('location', 'å®®å¤å³¶')}")

    # ãƒ¡ã‚¤ãƒ³ã‚³ãƒ³ãƒ†ãƒ³ãƒ„
    col1, col2 = st.columns([2, 1])

    with col1:
        # å…¥åŠ›ãƒ‡ãƒ¼ã‚¿ãƒ•ã‚©ãƒ¼ãƒ 
        input_data = predictor.create_input_data_form()

        # äºˆæ¸¬å®Ÿè¡Œ - APIãƒ‡ãƒ¼ã‚¿ã¾ãŸã¯é€šå¸¸ã®å…¥åŠ›ãƒ‡ãƒ¼ã‚¿ã§å®Ÿè¡Œ
        if input_data is not None or (
                hasattr(st.session_state, 'api_prediction_data') and st.session_state.api_prediction_data is not None):

            # APIãƒ‡ãƒ¼ã‚¿ãŒæº–å‚™ã•ã‚Œã¦ã„ã‚‹å ´åˆã¯ãã‚Œã‚’ä½¿ç”¨
            if hasattr(st.session_state, 'api_prediction_data') and st.session_state.api_prediction_data is not None:
                input_data = st.session_state.api_prediction_data
                st.session_state.api_prediction_data = None  # ä½¿ç”¨å¾Œã¯ã‚¯ãƒªã‚¢
                st.info("ğŸ“¡ Open-Meteo APIãƒ‡ãƒ¼ã‚¿ã‚’ä½¿ç”¨ã—ã¦äºˆæ¸¬ã‚’å®Ÿè¡Œã—ã¾ã™")

            with st.spinner("ğŸ”® äºˆæ¸¬è¨ˆç®—ä¸­..."):
                try:
                    # äºˆæ¸¬æ™‚é–“è»¸ãŒé¸æŠã•ã‚Œã¦ã„ã‚‹ã‹ãƒã‚§ãƒƒã‚¯
                    if not st.session_state.forecast_steps:
                        st.error("äºˆæ¸¬æ™‚é–“è»¸ã‚’é¸æŠã—ã¦ãã ã•ã„")
                        return

                    if not forecast_steps:
                        st.error("forecast_stepsãŒç©ºã§ã™ã€‚ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆå€¤ã‚’ä½¿ç”¨ã—ã¾ã™ã€‚")
                        forecast_steps = [1, 2, 4]

                    # å…¥åŠ›ãƒ‡ãƒ¼ã‚¿ã®æƒ…å ±ã‚’è¡¨ç¤º
                    st.write(f"**ğŸ“Š ä½¿ç”¨ãƒ‡ãƒ¼ã‚¿æƒ…å ±:**")
                    st.write(f"- ãƒ‡ãƒ¼ã‚¿ç‚¹æ•°: {len(input_data)}ä»¶")
                    st.write(f"- æ™‚åˆ»ç¯„å›²: {input_data['datetime'].min()} ã€œ {input_data['datetime'].max()}")
                    st.write(f"- å¹³å‡æ—¥å°„å¼·åº¦: {input_data['æ—¥å°„å¼·åº¦'].mean():.3f} kW/mÂ²")

                    # äºˆæ¸¬å®Ÿè¡Œ
                    predictions = loaded_predictor.predict_irradiance(
                        input_data,
                        model_name=st.session_state.model_type,
                        forecast_steps=forecast_steps
                    )

                    if predictions and len(predictions) > 0:
                        st.success("âœ… äºˆæ¸¬å®Œäº†ï¼")

                        # **éå»å®Ÿç¸¾ãƒ‡ãƒ¼ã‚¿ã®å–å¾—**
                        historical_data = None
                        if hasattr(st.session_state, 'openmeteo_data') and st.session_state.openmeteo_data is not None:
                            historical_data = st.session_state.openmeteo_data
                            st.info(f"ğŸ“ˆ éå»å®Ÿç¸¾ãƒ‡ãƒ¼ã‚¿: {len(historical_data)}ä»¶ã‚’å«ã‚ã¦è¡¨ç¤º")
                        elif st.session_state.use_openmeteo:
                            # è¿½åŠ ã§éå»ãƒ‡ãƒ¼ã‚¿ã‚’å–å¾—
                            with st.spinner("ğŸ“Š éå»å®Ÿç¸¾ãƒ‡ãƒ¼ã‚¿ã‚’å–å¾—ä¸­..."):
                                try:
                                    end_date = datetime.now().date()
                                    start_date = end_date - timedelta(days=3)  # éå»3æ—¥é–“

                                    historical_data = predictor.weather_api.get_historical_weather(
                                        datetime.combine(start_date, datetime.min.time()),
                                        datetime.combine(end_date, datetime.max.time())
                                    )

                                    if historical_data is not None:
                                        st.info(f"ğŸ“Š è¿½åŠ å–å¾—ã—ãŸéå»å®Ÿç¸¾: {len(historical_data)}ä»¶")
                                    else:
                                        st.warning("éå»å®Ÿç¸¾ãƒ‡ãƒ¼ã‚¿ã®å–å¾—ã«å¤±æ•—ã—ã¾ã—ãŸ")

                                except Exception as hist_error:
                                    st.warning(f"éå»ãƒ‡ãƒ¼ã‚¿å–å¾—ã‚¨ãƒ©ãƒ¼: {hist_error}")

                        # **çµæœè¡¨ç¤ºï¼ˆéå»å®Ÿç¸¾ä»˜ãï¼‰**
                        st.subheader("ğŸ“ˆ äºˆæ¸¬çµæœ")

                        # ãƒ‡ãƒ¼ã‚¿ãƒ†ãƒ¼ãƒ–ãƒ«ä½œæˆ
                        try:
                            report = loaded_predictor.create_prediction_report(input_data, predictions)

                            if report is not None and not report.empty:
                                # ãƒ‡ãƒ¼ã‚¿ãƒ†ãƒ¼ãƒ–ãƒ«è¡¨ç¤º
                                st.dataframe(report, use_container_width=True)

                                # **éå»å®Ÿç¸¾ã‚’å«ã‚€ã‚°ãƒ©ãƒ•è¡¨ç¤º**
                                try:
                                    fig = create_prediction_chart_with_historical(
                                        input_data=input_data,
                                        predictions=predictions,
                                        forecast_labels=st.session_state.forecast_steps,
                                        pv_capacity=st.session_state.pv_capacity,
                                        historical_data=historical_data  # éå»ãƒ‡ãƒ¼ã‚¿ã‚’è¿½åŠ 
                                    )
                                    st.plotly_chart(fig, use_container_width=True)

                                    # è¿½åŠ ã®çµ±è¨ˆæƒ…å ±
                                    if historical_data is not None:
                                        st.markdown("---")
                                        st.subheader("ğŸ“Š éå»å®Ÿç¸¾çµ±è¨ˆ")

                                        col_stat1, col_stat2, col_stat3, col_stat4 = st.columns(4)

                                        with col_stat1:
                                            past_avg = historical_data['æ—¥å°„å¼·åº¦'].mean()
                                            st.metric("éå»å¹³å‡æ—¥å°„å¼·åº¦", f"{past_avg:.3f} kW/mÂ²")

                                        with col_stat2:
                                            past_max = historical_data['æ—¥å°„å¼·åº¦'].max()
                                            st.metric("éå»æœ€å¤§æ—¥å°„å¼·åº¦", f"{past_max:.3f} kW/mÂ²")

                                        with col_stat3:
                                            current_val = st.session_state.current_irradiance
                                            vs_avg = ((current_val - past_avg) / past_avg * 100) if past_avg > 0 else 0
                                            st.metric("ç¾åœ¨å€¤ vs å¹³å‡", f"{vs_avg:+.1f}%")

                                        with col_stat4:
                                            data_span_hours = (historical_data['datetime'].max() - historical_data[
                                                'datetime'].min()).total_seconds() / 3600
                                            st.metric("ãƒ‡ãƒ¼ã‚¿æœŸé–“", f"{data_span_hours:.0f}æ™‚é–“")

                                except Exception as chart_error:
                                    st.error(f"ã‚°ãƒ©ãƒ•ä½œæˆã‚¨ãƒ©ãƒ¼: {chart_error}")
                                    # ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯ï¼šåŸºæœ¬ã‚°ãƒ©ãƒ•ã‚’è¡¨ç¤º
                                    try:
                                        basic_fig = create_prediction_chart_with_capacity(
                                            input_data, predictions, st.session_state.forecast_steps,
                                            st.session_state.pv_capacity
                                        )
                                        st.plotly_chart(basic_fig, use_container_width=True)
                                    except:
                                        st.error("åŸºæœ¬ã‚°ãƒ©ãƒ•ã®è¡¨ç¤ºã«ã‚‚å¤±æ•—ã—ã¾ã—ãŸ")


                                # CSVãƒ€ã‚¦ãƒ³ãƒ­ãƒ¼ãƒ‰ï¼ˆéå»ãƒ‡ãƒ¼ã‚¿ä»˜ãï¼‰
                                try:
                                    download_data = report.copy()

                                    # éå»ãƒ‡ãƒ¼ã‚¿ãŒåˆ©ç”¨å¯èƒ½ãªå ´åˆã¯è¿½åŠ æƒ…å ±ã‚’ä»˜ä¸
                                    if historical_data is not None:
                                        past_avg = historical_data['æ—¥å°„å¼·åº¦'].mean()
                                        download_data['éå»å¹³å‡æ—¥å°„å¼·åº¦'] = f"{past_avg:.3f}"
                                        download_data[
                                            'ãƒ‡ãƒ¼ã‚¿æœŸé–“'] = f"{historical_data['datetime'].min()} - {historical_data['datetime'].max()}"

                                    csv = download_data.to_csv(index=False, encoding='utf-8-sig')
                                    st.download_button(
                                        label="ğŸ“¥ çµæœã‚’CSVãƒ€ã‚¦ãƒ³ãƒ­ãƒ¼ãƒ‰ï¼ˆéå»ãƒ‡ãƒ¼ã‚¿çµ±è¨ˆä»˜ãï¼‰",
                                        data=csv,
                                        file_name=f"miyako_pv_prediction_with_historical_{datetime.now().strftime('%Y%m%d_%H%M%S')}.csv",
                                        mime="text/csv"
                                    )
                                except Exception as csv_error:
                                    st.warning(f"CSVãƒ€ã‚¦ãƒ³ãƒ­ãƒ¼ãƒ‰æº–å‚™ã‚¨ãƒ©ãƒ¼: {csv_error}")

                            else:
                                st.error("ãƒ¬ãƒãƒ¼ãƒˆä½œæˆã«å¤±æ•—ã—ã¾ã—ãŸ")

                        except Exception as report_error:
                            st.error(f"ãƒ¬ãƒãƒ¼ãƒˆä½œæˆã‚¨ãƒ©ãƒ¼: {report_error}")

                    else:
                        st.error("äºˆæ¸¬ã«å¤±æ•—ã—ã¾ã—ãŸ")

                except Exception as e:
                    st.error(f"äºˆæ¸¬ã‚¨ãƒ©ãƒ¼: {e}")
                    import traceback
                    st.code(f"Error details:\n{traceback.format_exc()}")

    with col2:
        # å³ã‚µã‚¤ãƒ‰ãƒ‘ãƒãƒ«ï¼šå®®å¤å³¶ã‚·ã‚¹ãƒ†ãƒ æƒ…å ±
        st.subheader("ğŸï¸ å®®å¤å³¶ã‚·ã‚¹ãƒ†ãƒ æƒ…å ±")

        with st.container():
            st.metric(
                label="ç·PVå®¹é‡",
                value=f"{st.session_state.pv_capacity:.0f} MW",
                help="å®®å¤å³¶å…¨åœŸã®å¤ªé™½å…‰ç™ºé›»ç·å®¹é‡"
            )

            st.metric(
                label="æœ€å¤§æœŸå¾…å‡ºåŠ›",
                value=f"{st.session_state.pv_capacity * st.session_state.total_efficiency:.0f} MW",
                delta=f"åŠ¹ç‡: {st.session_state.total_efficiency:.1%}",
                help="ç¾åœ¨ã®æ¡ä»¶ã§ã®æœ€å¤§å‡ºåŠ›"
            )

            st.metric(
                label="äºˆæ¸¬æ™‚é–“è»¸",
                value=f"{len(st.session_state.forecast_steps)}ç¨®é¡",
                help="é¸æŠã•ã‚ŒãŸäºˆæ¸¬æ™‚é–“è»¸ã®æ•°"
            )

            st.metric(
                label="ä½¿ç”¨ã‚¢ãƒ«ã‚´ãƒªã‚ºãƒ ",
                value=st.session_state.model_type,
                help="é¸æŠã•ã‚ŒãŸæ©Ÿæ¢°å­¦ç¿’ã‚¢ãƒ«ã‚´ãƒªã‚ºãƒ "
            )

        # ã‚·ã‚¹ãƒ†ãƒ çŠ¶æ…‹
        st.subheader("ğŸ”§ ã‚·ã‚¹ãƒ†ãƒ çŠ¶æ…‹")
        st.success("ğŸŸ¢ ãƒ¢ãƒ‡ãƒ«: æ­£å¸¸")
        st.success("ğŸŸ¢ äºˆæ¸¬ã‚¨ãƒ³ã‚¸ãƒ³: ç¨¼åƒä¸­")

        # APIçŠ¶æ…‹è¡¨ç¤º
        if st.session_state.api_enabled:
            st.success("ğŸŸ¢ Open-Meteo API: æœ‰åŠ¹")
        else:
            st.info("ğŸ”µ API: ç„¡åŠ¹ï¼ˆæ‰‹å‹•å…¥åŠ›ãƒ¢ãƒ¼ãƒ‰ï¼‰")

        st.info("ğŸ”µ ãƒ‡ãƒ¼ã‚¿: æº–å‚™å®Œäº†")

        # ç¾åœ¨ã®å®®å¤å³¶æ°—è±¡æ¡ä»¶ã‚µãƒãƒªãƒ¼
        st.subheader("ğŸŒ´ ç¾åœ¨ã®å®®å¤å³¶æ¡ä»¶")

        col_weather1, col_weather2 = st.columns(2)
        with col_weather1:
            st.write(f"**å¤©å€™:** {st.session_state.weather_condition}")
            st.write(f"**æ°—æ¸©:** {st.session_state.temperature}Â°C")
            st.write(f"**å­£ç¯€:** {st.session_state.season_factor}")
        with col_weather2:
            st.write(f"**é›²é‡:** {st.session_state.cloud_cover}%")
            st.write(f"**æ—¥å°„å¼·åº¦:** {st.session_state.current_irradiance:.3f}")
            st.write(f"**æ°—è±¡ãƒªã‚¹ã‚¯:** {st.session_state.weather_risk}")

        # åŠ¹ç‡æŒ‡æ¨™
        efficiency = st.session_state.total_efficiency
        if efficiency > 0.18:
            st.success(f"ğŸŒŸ ç™ºé›»åŠ¹ç‡: {efficiency:.1%}")
        elif efficiency > 0.14:
            st.info(f"âœ… ç™ºé›»åŠ¹ç‡: {efficiency:.1%}")
        else:
            st.warning(f"âš ï¸ ç™ºé›»åŠ¹ç‡: {efficiency:.1%}")

        # APIæƒ…å ±è¡¨ç¤ºï¼ˆæœ‰åŠ¹æ™‚ã®ã¿ï¼‰
        if st.session_state.api_enabled:
            st.subheader("ğŸŒ APIæƒ…å ±")
            if hasattr(st.session_state, 'openmeteo_data') and st.session_state.openmeteo_data is not None:
                st.success(f"ğŸ“¡ å–å¾—æ¸ˆã¿ãƒ‡ãƒ¼ã‚¿: {len(st.session_state.openmeteo_data)}ä»¶")

                # æœ€æ–°ãƒ‡ãƒ¼ã‚¿ã®æ¦‚è¦
                latest_data = st.session_state.openmeteo_data.tail(1)
                if len(latest_data) > 0:
                    latest_row = latest_data.iloc[0]
                    st.write(f"**æœ€æ–°å–å¾—æ™‚åˆ»:** {latest_row['datetime'].strftime('%H:%M')}")
                    st.write(f"**APIæ—¥å°„å¼·åº¦:** {latest_row['æ—¥å°„å¼·åº¦']:.3f} kW/mÂ²")
            else:
                st.info("ãƒ‡ãƒ¼ã‚¿æœªå–å¾—")


if __name__ == "__main__":
    main()
